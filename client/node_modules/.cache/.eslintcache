[{"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\index.js":"1","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\reportWebVitals.js":"2","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\Lema.js":"3","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\LeftBar.jsx":"4","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Banner.jsx":"5","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Map.jsx":"6","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\CollectionArea.jsx":"7","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\ControlBox.jsx":"8","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\ContextMenu.jsx":"9","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\AddEditNodeModal.jsx":"10","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Collection.jsx":"11","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Textbox.jsx":"12","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Button.jsx":"13","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\RadioGroup.jsx":"14","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\AddEditCollectionModal.jsx":"15","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\ColourPicker.jsx":"16","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\LabeledControl.jsx":"17","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Meatballs.jsx":"18","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Collapser.jsx":"19","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\LoginRegisterModal.jsx":"20"},{"size":503,"mtime":1636387521627,"results":"21","hashOfConfig":"22"},{"size":362,"mtime":499162500000,"results":"23","hashOfConfig":"22"},{"size":14521,"mtime":1650478544925,"results":"24","hashOfConfig":"22"},{"size":1024,"mtime":1650475185861,"results":"25","hashOfConfig":"22"},{"size":1061,"mtime":1650477463130,"results":"26","hashOfConfig":"22"},{"size":26497,"mtime":1650475283315,"results":"27","hashOfConfig":"22"},{"size":4398,"mtime":1650475169471,"results":"28","hashOfConfig":"22"},{"size":4166,"mtime":1650475179784,"results":"29","hashOfConfig":"22"},{"size":622,"mtime":1650475059232,"results":"30","hashOfConfig":"22"},{"size":15999,"mtime":1650475126177,"results":"31","hashOfConfig":"22"},{"size":5295,"mtime":1650475150078,"results":"32","hashOfConfig":"22"},{"size":864,"mtime":1650475077664,"results":"33","hashOfConfig":"22"},{"size":611,"mtime":1647013078795,"results":"34","hashOfConfig":"22"},{"size":1748,"mtime":1650475070788,"results":"35","hashOfConfig":"22"},{"size":3124,"mtime":1650475100494,"results":"36","hashOfConfig":"22"},{"size":637,"mtime":1647089426759,"results":"37","hashOfConfig":"22"},{"size":481,"mtime":1650476894366,"results":"38","hashOfConfig":"22"},{"size":724,"mtime":1647016194577,"results":"39","hashOfConfig":"22"},{"size":428,"mtime":1650475053516,"results":"40","hashOfConfig":"22"},{"size":6240,"mtime":1650478450365,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"mz6ydj",{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"44"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"44"},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"44"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"44"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"73","messages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"86","messages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\index.js",[],["88","89"],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\reportWebVitals.js",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\Lema.js",["90"],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\LeftBar.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Banner.jsx",["91"],"import {Component} from \"react\";\r\nimport {LoginRegisterModal} from \"./modals/LoginRegisterModal\";\r\n\r\nexport class Banner extends Component\r\n{\r\n\tconstructor(props)\r\n\t{\r\n\t\tsuper(props);\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\tlet text = \"Save your maps and share them with the community:\";\r\n\t\tlet buttons = [\r\n\t\t\t<div className={\"login-button\"} onClick={(e) => {\r\n\t\t\t\tthis.props.openModal(e, <LoginRegisterModal mode={\"login\"} handler={this.props.authenticateUser} />);\r\n\t\t\t}}>\r\n\t\t\t\tLogin\r\n\t\t\t</div>,\r\n\t\t\t<div className={\"register-button\"} onClick={(e) => {\r\n\t\t\t\tthis.props.openModal(e, <LoginRegisterModal mode={\"register\"} handler={this.props.registerUser} />);\r\n\t\t\t}}>\r\n\t\t\t\tRegister\r\n\t\t\t</div>\r\n\t\t];\r\n\t\tif(this.props.activeUser)\r\n\t\t{\r\n\t\t\ttext = \"\";\r\n\t\t\tbuttons = [\r\n\t\t\t\t<div className={\"showcase-button\"}>\r\n\t\t\t\t\tCommunity Showcase\r\n\t\t\t\t</div>\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\treturn(\r\n\t\t\t<div className={\"banner-container\"}>\r\n\t\t\t\t<h2>LEMA: Linguistic Etymology Map Assistant</h2>\r\n\t\t\t\t<p>{text}</p>\r\n\t\t\t\t<div className={\"buttons-container\"}>\r\n\t\t\t\t\t{buttons}\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n}","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Map.jsx",["92","93","94","95","96","97","98","99","100","101","102","103","104","105","106"],"import React, {useEffect, useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {AddEditNodeModal} from \"./modals/AddEditNodeModal\";\r\nimport {ContextMenu} from \"./controls/ContextMenu\";\r\nimport countriesData from \"../data/countries/countries.json\";\r\nimport languageProperties from \"../data/languageProperties.json\";\r\n\r\nexport function Map(props)\r\n{\r\n\tconsole.log(\"[== MAP RENDER ==]\");\r\n\r\n\t// Prop functions\r\n\tconst openContextMenu = props.openContextMenu.bind(this);\r\n\tconst addNode = props.addNode.bind(this);\r\n\tconst editNode = props.editNode.bind(this);\r\n\tconst removeNode = props.removeNode.bind(this);\r\n\tconst openModal = props.openModal.bind(this);\r\n\r\n\t// Props\r\n\tconst collections = props.collections;\r\n\r\n\t// DEBUG MODE\r\n\tconst DEBUG_MODE = true;\r\n\r\n\t// Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\r\n\tuseEffect(() => {\r\n\t\tconst svg = d3.selectAll(\".map-container\").selectAll(\"svg\");\r\n\t\tconst countries = countriesData.features;\r\n\r\n\t\t// Create path (passed as svg attribute later to draw the countries)\r\n\t\t// TODO: Have it auto-scale as window is dragged\r\n\t\tconst width = svg._groups[0][0].clientWidth;\r\n\t\tconst height = svg._groups[0][0].clientHeight;\r\n\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t.center([8, 52.823]) // Middle of Europe(ish)\r\n\t\t\t.scale(1650)\r\n\t\t\t.translate([width/2, height/2]);\r\n\t\tconst path = d3.geoPath().projection(projection);\r\n\r\n\t\tlet coordGroup;\r\n\t\tif(DEBUG_MODE)\r\n\t\t{\r\n\t\t\tcoordGroup = svg.append(\"g\")\r\n\t\t\t\t.classed(\"coords\", true)\r\n\t\t\t\t.attr('transform', 'translate(50,150)')\r\n\t\t}\r\n\r\n\r\n\t\t// Draw countries, bind data and handlers\r\n\t\tconst countryPaths = svg.append(\"g\")\r\n\t\t\t.selectAll(\"path\") // svg->g->path\r\n\t\t\t.data(countries)         // svg->g->path\r\n\t\t\t.enter()                 // svg->g->path (create new nodes per data)\r\n\t\t\t.append(\"path\")          // svg->g->path (create new nodes per data)\r\n\t\t\t.attr(\"fill\", (d) => determineFillColour(d))\r\n\t\t\t.attr(\"stroke\", (d) => determineStrokeColour(d))\r\n\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t.attr(\"d\", path)\r\n\t\t\t.on(\"click\", function(e, d){\r\n\t\t\t\t// TODO: Possibly same functions as context menu (see about calling this.onContextMenu() to keep things nice and DRY)\r\n\t\t\t})\r\n\t\t\t.on(\"mousemove\", function(e, d)\r\n\t\t\t{\r\n\t\t\t\tif(DEBUG_MODE)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst x = e.offsetX - 612, y = e.offsetY - 528;\r\n\t\t\t\t\tcoordGroup.selectAll(\"text\").remove();\r\n\t\t\t\t\tcoordGroup.append(\"text\")\r\n\t\t\t\t\t\t.text(`(${x},${y})`)\r\n\t\t\t\t\t\t.attr(\"fill\", \"white\");\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.on(\"contextmenu\", function(e, d){\r\n\t\t\t\te.preventDefault(); // Prevent browser context menu from opening\r\n\t\t\t\tconst nodeObject = findNodes(d, \"cognate\");\r\n\t\t\t\tlet contextMenuItems = [];\r\n\r\n\t\t\t\t// If clicked-on country has attached cognate\r\n\t\t\t\tif(nodeObject)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Edit node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={editNode} node={nodeObject.node} collectionList={collectionList}\r\n\t\t\t\t\t\t\t\t                               collectionIndex={nodeObject.collectionIndex}\r\n\t\t\t\t\t\t\t\t                               type={\"cognate\"} language={nodeObject.node.language} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Remove node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tremoveNode(e, nodeObject.collectionIndex, nodeObject.arrayIndex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: Context menu for adding to new collection, adding to existing collection\r\n\t\t\t\t\tcontextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add country to collection (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\tif(collectionList.length <= 0)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\talert(\"You must first create a cognate collection for the node to be added to.\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst node = {word: \"\", language: \"\", parents: []};\r\n\t\t\t\t\t\t\t\t\tnode.fillColour = \"#FF0000\"; node.strokeColour = \"#000000\";\r\n\t\t\t\t\t\t\t\t\tnode.label = {type: \"word\", customText: \"\", fontColour: \"#000000\", fontSize: null, x: null, y: null};\r\n\t\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal isNewWord={true} onNodeSubmit={addNode} node={node} type={\"cognate\"} collectionList={collectionList} collectionIndex={collectionList[0].collectionIndex} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Common to both\r\n\t\t\t\tcontextMenuItems.unshift(\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttext: \"Add new node (journey)\", handler: (e) => {\r\n\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\tif(collectionList.length <= 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\talert(\"You must first create a journey collection for the node to be added to.\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Open the AddEditNodeModal with initial node data\r\n\t\t\t\t\t\t\t\tconst node = {word: \"\", language: d.properties.languages[0], parents: []};\r\n\t\t\t\t\t\t\t\tnode.vertex = {type: \"word\", customText: \"\", fontColour: \"#000000\", strokeColour: \"#000000\", fillColour: \"#FFFFFF\", radius: null, fontSize: null, x: null, y: null, edgeStart: \"centre\", edgeEnd: \"centre\", edgeStrokeColour: \"#000000\", edgeStrokeWidth: \"2px\", edgeArrowheadEnabled: true, edgeArrowheadStrokeColour: \"#000000\", edgeArrowheadFillColour: \"#000000\"};\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal isNewWord={true} node={node} type={\"journey\"} onNodeSubmit={addNode} collectionList={collectionList} collectionIndex={collectionList[0].collectionIndex} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t})\r\n\t\t\t.on(\"mouseover\", function(e, d){\r\n\t\t\t\tconst element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"white\") // White can't become transparent\r\n\t\t\t\t\telement.attr(\"fill\", \"rgb(230,230,230)\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"0.65\");\r\n\t\t\t})\r\n\t\t\t.on(\"mouseout\", function(e, d){\r\n\t\t\t\tconst element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"rgb(230,230,230)\") // Reset white\r\n\t\t\t\t\telement.attr(\"fill\", \"white\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"1\");\r\n\t\t\t});\r\n\r\n\t\t// Cognate labels, journey vertices\r\n\t\tconst vertexEdgesG = svg.append(\"g\").classed(\"vertex-edges\", true); // SVG group for edges\r\n\t\tconst verticesLabelsG = svg.append(\"g\").classed(\"vertices-labels\", true); // SVG group for vertices AND cognate labels\r\n\t\tcountryPaths.each(function(f, i) {\r\n\t\t\tconst cognateNodeObject = findNodes(f, \"cognate\");  // The first node in any cognate collection that belongs to this country/region\r\n\t\t\tif(cognateNodeObject)\r\n\t\t\t{\r\n\t\t\t\t/* Cognate visualisations */\r\n\t\t\t\tconst node = cognateNodeObject.node;\r\n\t\t\t\tconst boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\r\n\t\t\t\tlet fontSize = node.label.fontSize;                 // Font size of the label\r\n\t\t\t\tlet labelText = node.word;                          // Word by default\r\n\t\t\t\tif(node.label.type === \"Country/region\") labelText = f.properties.name_long;\r\n\t\t\t\telse if(node.label.type === \"Custom text\") labelText = node.label.customText;\r\n\t\t\t\telse if(node.label.type === \"Language\") labelText = node.language;\r\n\r\n\t\t\t\t// TODO: Initial scale factor depending on size of country (to stop oversized text from escaping country)\r\n\t\t\t\tif(labelText.length !== 0 && !node.label.fontSize) // Only scale if font size hasn't been set by user\r\n\t\t\t\t{\r\n\t\t\t\t\tif(boundingBox.width < (labelText.length * 16))\r\n\t\t\t\t\t\tfontSize = boundingBox.width/8 + \"px\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Append labels to paths, with co-ordinates according to feature's position on map\r\n\t\t\t\tlet x = (node.label.x === null) ? (boundingBox.x + boundingBox.width/4) : node.label.x;\r\n\t\t\t\tlet y = (node.label.y === null) ? (boundingBox.y + boundingBox.height/2) : node.label.y;\r\n\t\t\t\tconst label = verticesLabelsG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", x).attr(\"y\", y)\r\n\t\t\t\t\t.attr(\"fill\", node.label.fontColour)\r\n\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t.text(labelText);\r\n\r\n\t\t\t\t// Dragging/resizing handlers\r\n\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startSize, newSize;\r\n\t\t\t\tlabel\r\n\t\t\t\t\t.on(\"mousemove\", (e) => {\r\n\t\t\t\t\t\tconst labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\tconst mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"grab\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.call(d3.drag()\r\n\t\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\t\tconst labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tstartXOffset = mouseX - labelX;\r\n\t\t\t\t\t\t\tstartYOffset = mouseY - labelY;\r\n\r\n\t\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\t\tstartSize = parseFloat(label.style(\"font-size\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Resize the label\r\n\t\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\t\tnewSize = startSize + (deltaX / 10);\r\n\t\t\t\t\t\t\t\t\tif(newSize < 5) newSize = 5; // Floor of 5px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\t\tlabel.style(\"font-size\", newSize + \"px\"); // Only visually, not updating state itself\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Move the label\r\n\t\t\t\t\t\t\t\tx = mouseX - startXOffset;\r\n\t\t\t\t\t\t\t\ty = mouseY - startYOffset;\r\n\t\t\t\t\t\t\t\tnewSize = node.label.fontSize;\r\n\t\t\t\t\t\t\t\tlabel.attr(\"x\", x).attr(\"y\", y); // Only visually\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\t\tnode.label.x = x; node.label.y = y; node.label.fontSize = newSize;\r\n\t\t\t\t\t\t\teditNode(null, cognateNodeObject.collectionIndex, node);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Journeys\r\n\t\tconst journeyNodeObjects = findNodes(null, \"journey\");\r\n\t\tif(journeyNodeObjects)\r\n\t\t{\r\n\t\t\t/* Journey visualisations */\r\n\r\n\t\t\t// Loop through all journey nodes inside this country/region\r\n\t\t\tlet startEdgeXOffset = 0, startEdgeYOffset = 0, endEdgeXOffset = 0, endEdgeYOffset = 0; // Centre by default\r\n\t\t\tfor(let i = 0; i < journeyNodeObjects.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tconst journeyNodeObject = journeyNodeObjects[i];\r\n\t\t\t\tconst node = journeyNodeObject.node;\r\n\t\t\t\tconst languageProp = getLanguageProp(node);\r\n\t\t\t\tlet radius = node.vertex.radius || languageProp.radius || 50; // Inherit radius (determined later if null)\r\n\t\t\t\tconst fontSize = node.vertex.fontSize;\r\n\t\t\t\tlet vertexText = node.word;  // Word by default\r\n\t\t\t\tif(node.vertex.type === \"Custom text\") vertexText = node.vertex.customText;\r\n\t\t\t\telse if(node.vertex.type === \"Language\") vertexText = node.language;\r\n\r\n\t\t\t\t/* Build node elements - VERTEX */\r\n\r\n\t\t\t\t// Initial co-ordinates\r\n\t\t\t\tlet vertexX = (node.vertex.x === null) ? (languageProp.x + 612) : node.vertex.x;\r\n\t\t\t\tlet vertexY = (node.vertex.y === null) ? (languageProp.y + 528) : node.vertex.y;\r\n\r\n\t\t\t\t// Set initial vertex position\r\n\t\t\t\tif(!node.vertex.x || !node.vertex.y)\r\n\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY;\r\n\r\n\t\t\t\t// Prepare text element. This is required to calculate circle radius based on text element's width\r\n\t\t\t\tconst vertexG = verticesLabelsG.append(\"g\"); // Group required to have circle and text together\r\n\t\t\t\tconst preparedText = vertexG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fontColour)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t.style(\"font-size\", \"16px\")\r\n\t\t\t\t\t.text(vertexText);\r\n\r\n\t\t\t\t// Determine initial radius of circle\r\n\t\t\t\tconst innerTextWidth = preparedText.node().getBBox().width;\r\n\t\t\t\tif(vertexText.length !== 0 && !node.vertex.radius) // Only scale if font size hasn't been set by user\r\n\t\t\t\t{\r\n\t\t\t\t\tif(radius < innerTextWidth) radius = innerTextWidth/2 + 5; // Convert text \"diameter\" to radius, add padding\r\n\t\t\t\t}\r\n\t\t\t\tpreparedText.remove(); // Remove prepared text element. It will not show if appended before the circle\r\n\r\n\t\t\t\t/* Build node elements - EDGE */\r\n\r\n\t\t\t\t// Place edge between this node and its parents\r\n\t\t\t\tlet markerSelectString = \"\"; // String to select markers so that they can move whilst being resized\r\n\t\t\t\tif(node.parents)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Create edge for each parent, originating from this node\r\n\t\t\t\t\tfor(let i = 0; i < node.parents.length; ++i)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst parentNode = node.parents[i];\r\n\r\n\t\t\t\t\t\t// Fingerprint references for marker IDs and data-start/data-end attributes\r\n\t\t\t\t\t\tconst parentRef = journeyNodeObject.collectionIndex + \"|\" + parentNode.arrayIndex;\r\n\t\t\t\t\t\tconst nodeRef = journeyNodeObject.collectionIndex + \"|\" + node.arrayIndex;\r\n\r\n\t\t\t\t\t\t// Compute arrowheads\r\n\t\t\t\t\t\tif(node.vertex.edgeArrowheadEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvertexEdgesG.append(\"defs\")\r\n\t\t\t\t\t\t\t\t.append(\"marker\")\r\n\t\t\t\t\t\t\t\t.attr(\"id\", \"arrow\" + parentRef + nodeRef)\r\n\t\t\t\t\t\t\t\t.attr(\"markerWidth\", 5).attr(\"markerHeight\", 4)\r\n\t\t\t\t\t\t\t\t.attr(\"refX\", radius/2 + 5).attr(\"refY\", 2)\r\n\t\t\t\t\t\t\t\t.attr(\"orient\", \"auto\")\r\n\t\t\t\t\t\t\t\t.append(\"polygon\")\r\n\t\t\t\t\t\t\t\t.attr(\"points\", \"0 0, 5 2, 0 4\")\r\n\t\t\t\t\t\t\t\t.attr(\"fill\", node.vertex.edgeArrowheadFillColour)\r\n\t\t\t\t\t\t\t\t.attr(\"stroke\", node.vertex.edgeArrowheadStrokeColour)\r\n\t\t\t\t\t\t\t\t.attr(\"id\", nodeRef);\r\n\t\t\t\t\t\t\tmarkerSelectString += \"marker[id=\\\"arrow\"+parentRef+nodeRef+\"\\\"], \";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Determine edge start position\r\n\t\t\t\t\t\tif(node.vertex.edgeStart === \"top\") startEdgeYOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"right\") startEdgeXOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"bottom\") startEdgeYOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"left\") startEdgeXOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"centre\") {\r\n\t\t\t\t\t\t\tstartEdgeXOffset = 0; startEdgeYOffset = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Determine edge end position\r\n\t\t\t\t\t\tif(node.vertex.edgeEnd === \"top\") endEdgeYOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"right\") endEdgeXOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"bottom\") endEdgeYOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"left\") endEdgeXOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"centre\") {\r\n\t\t\t\t\t\t\tendEdgeXOffset = 0; endEdgeYOffset = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Place edge\r\n\t\t\t\t\t\tconst edge = vertexEdgesG.append(\"line\")\r\n\t\t\t\t\t\t\t.attr(\"x1\", parentNode.vertex.x + startEdgeXOffset)\r\n\t\t\t\t\t\t\t.attr(\"y1\", parentNode.vertex.y + startEdgeYOffset)\r\n\t\t\t\t\t\t\t.attr(\"x2\", node.vertex.x + endEdgeXOffset)\r\n\t\t\t\t\t\t\t.attr(\"y2\", node.vertex.y + endEdgeYOffset)\r\n\t\t\t\t\t\t\t.attr(\"stroke\", node.vertex.edgeStrokeColour)\r\n\t\t\t\t\t\t\t.attr(\"stroke-width\", node.vertex.edgeStrokeWidth)\r\n\t\t\t\t\t\t\t.attr(\"data-start\", parentRef) // For finding attached edges later\r\n\t\t\t\t\t\t\t.attr(\"data-end\", nodeRef);\r\n\r\n\t\t\t\t\t\tif(node.vertex.edgeArrowheadEnabled)\r\n\t\t\t\t\t\t\tedge.attr(\"marker-end\", \"url(#arrow\"+parentRef+nodeRef+\")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Place node elements\r\n\t\t\t\tconst vertex = vertexG.append(\"circle\")\r\n\t\t\t\t\t.attr(\"cx\", vertexX).attr(\"cy\", vertexY)\r\n\t\t\t\t\t.attr(\"r\", radius + \"px\")\r\n\t\t\t\t\t.attr(\"stroke\", node.vertex.strokeColour)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fillColour);\r\n\t\t\t\tconst text = vertexG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fontColour)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t.text(vertexText);\r\n\r\n\t\t\t\t// Dragging/resizing/clicking handlers\r\n\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startRadius, newVertexRadius, newLabelSize;\r\n\t\t\t\tconst nodeContextMenuHandler = (e) => {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tconst contextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Edit node\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={editNode} node={node} collectionList={collectionList}\r\n\t\t\t\t\t\t\t\t                               collectionIndex={journeyNodeObject.collectionIndex}\r\n\t\t\t\t\t\t\t\t                               type={\"cognate\"} language={node.language} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Remove node\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tremoveNode(e, journeyNodeObject.collectionIndex, node.arrayIndex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t\t};\r\n\t\t\t\tconst nodeDragHandler = d3.drag()\r\n\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\tconst vertexX = parseFloat(vertex.attr(\"cx\")), vertexY = parseFloat(vertex.attr(\"cy\"));\r\n\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\tstartX = vertexX;\r\n\t\t\t\t\t\tstartY = vertexY;\r\n\t\t\t\t\t\tstartXOffset = mouseX - vertexX;\r\n\t\t\t\t\t\tstartYOffset = mouseY - vertexY;\r\n\r\n\t\t\t\t\t\t// Dimensions of bottom-right corner\r\n\t\t\t\t\t\tconst squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\r\n\t\t\t\t\t\tconst circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")),2);\r\n\t\t\t\t\t\tconst cornerWidth = ((squareArea - circleArea) / 4) / 2; // Extract corners, divide by four, width and height are equal length (/2)\r\n\r\n\t\t\t\t\t\t// Determine corner of circle's box\r\n\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\txStart: vertexX,\r\n\t\t\t\t\t\t\txEnd: vertexX + cornerWidth,\r\n\t\t\t\t\t\t\tyStart: vertexY,\r\n\t\t\t\t\t\t\tyEnd: vertexY + cornerWidth\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\tstartRadius = parseFloat(vertex.attr(\"r\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Resize the vertex\r\n\t\t\t\t\t\t\t\tconst deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\tnewVertexRadius = startRadius + (deltaX / 10);\r\n\t\t\t\t\t\t\t\tif(newVertexRadius < 10) newVertexRadius = 10; // Floor of 10px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\tvertex.attr(\"r\", newVertexRadius + \"px\"); // Only visually, not updating state itself\r\n\r\n\t\t\t\t\t\t\t\t// Resize the vertex's text\r\n\t\t\t\t\t\t\t\tconst paddingOffset = 10;\r\n\t\t\t\t\t\t\t\tnewLabelSize = ((((newVertexRadius*2) - paddingOffset) / innerTextWidth) * 100) + \"%\";\r\n\t\t\t\t\t\t\t\ttext.style(\"font-size\", newLabelSize);\r\n\r\n\t\t\t\t\t\t\t\t// Move arrowheads as it is resized\r\n\t\t\t\t\t\t\t\tif(markerSelectString)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst selectString = markerSelectString.slice(0, markerSelectString.length-2); // Trim \", \" at the end of string\r\n\t\t\t\t\t\t\t\t\td3.selectAll(selectString).attr(\"refX\", newVertexRadius/2+5);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Move the vertex\r\n\t\t\t\t\t\t\tvertexX = mouseX - startXOffset;\r\n\t\t\t\t\t\t\tvertexY = mouseY - startYOffset;\r\n\t\t\t\t\t\t\tvertex.attr(\"cx\", vertexX).attr(\"cy\", vertexY); // Only visually\r\n\t\t\t\t\t\t\ttext.attr(\"x\", vertexX).attr(\"y\", vertexY); // Only visually\r\n\r\n\t\t\t\t\t\t\t// Move the edges\r\n\t\t\t\t\t\t\tconst dataEnd = journeyNodeObject.collectionIndex + \"|\" + journeyNodeObject.node.arrayIndex;\r\n\t\t\t\t\t\t\tconst attachedEdges = d3.selectAll(\"line[data-start=\\\"\"+dataEnd+\"\\\"]\"); // Find all edges that start on this node\r\n\t\t\t\t\t\t\tconst attachedEdges2 = d3.selectAll(\"line[data-end=\\\"\"+dataEnd+\"\\\"]\");  // Find all edges that end on this node\r\n\t\t\t\t\t\t\tif(attachedEdges)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tattachedEdges.attr(\"x1\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t.attr(\"y1\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(attachedEdges2)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tattachedEdges2.attr(\"x2\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t.attr(\"y2\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY; node.vertex.radius = newVertexRadius || node.vertex.radius; node.vertex.fontSize = newLabelSize || node.vertex.fontSize;\r\n\t\t\t\t\t\teditNode(null, journeyNodeObject.collectionIndex, node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t// Assign handlers\r\n\t\t\t\ttext.on(\"contextmenu\", nodeContextMenuHandler);\r\n\t\t\t\ttext.call(nodeDragHandler);\r\n\t\t\t\tvertex.on(\"mousemove\", (e) => {\r\n\t\t\t\t\tconst vertexX = parseFloat(vertex.attr(\"cx\")), vertexY = parseFloat(vertex.attr(\"cy\"));\r\n\t\t\t\t\tconst mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t// Dimensions of bottom-right corner\r\n\t\t\t\t\tconst squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\r\n\t\t\t\t\tconst circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")),2);\r\n\t\t\t\t\tconst cornerWidth = ((squareArea - circleArea) / 4) / 2; // Extract corners, divide by four, width and height are equal length (/2)\r\n\r\n\t\t\t\t\t// Determine corner of circle's box\r\n\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\txStart: vertexX,\r\n\t\t\t\t\t\txEnd: vertexX + cornerWidth,\r\n\t\t\t\t\t\tyStart: vertexY,\r\n\t\t\t\t\t\tyEnd: vertexY + cornerWidth\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Check corner\r\n\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvertex.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvertex.style(\"cursor\", \"grab\");\r\n\t\t\t\t})\r\n\t\t\t\t.on(\"contextmenu\", nodeContextMenuHandler)\r\n\t\t\t\t.call(nodeDragHandler);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Graticules (lines on the map)\r\n\t\tconst g = svg.append(\"g\");\r\n\t\tconst graticules = g.classed(\"graticules\", true)\r\n\t\t\t.append(\"path\")\r\n\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\")\r\n\t\t\t.attr(\"d\", path(d3.geoGraticule()()));\r\n\r\n\t\t/*\r\n\t\tsvg.call(d3.zoom().on(\"zoom\", function () {\r\n\t\t\tz = d3.event.transform.k;\r\n\t\t\tdraw(); // TODO: Contain above render code into draw() function\r\n\t\t}));\r\n\t\t */\r\n\r\n\t\t// Clean-up function (kills all SVG elements upon unmounting)\r\n\t\treturn function cleanup()\r\n\t\t{\r\n\t\t\tsvg.selectAll(\"g\").remove();\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tfunction getLanguageProp(node)\r\n\t{\r\n\t\tfor(const l in languageProperties)\r\n\t\t{\r\n\t\t\tconst languageProp = languageProperties[l];\r\n\t\t\tif(languageProp.language === node.language)\r\n\t\t\t\treturn languageProp;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds all nodes in all collections of specified type where the node's language is within the feature's language array\r\n\t * @param {*} d The dataset feature (country/region) currently being rendered\r\n\t * @param {string} type The type of collection to search for (\"journey\" or \"cognate\")\r\n\t */\r\n\tfunction findNodes(d, type)\r\n\t{\r\n\t\t// Search collections\r\n\t\tif(type === \"cognate\")\r\n\t\t{\r\n\t\t\tfor(let c = 0; c < collections.length; ++c)\r\n\t\t\t{\r\n\t\t\t\tconst collection = collections[c];\r\n\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst childNode = collection.words[n];\r\n\r\n\t\t\t\t\t\tif(d.properties.languages.includes(childNode.language))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn {node: childNode, collectionIndex: c, arrayIndex: n}; // TODO: Currently only returns first cognate\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(type === \"journey\")\r\n\t\t{\r\n\t\t\tconst journeyNodeObjects = [];\r\n\t\t\tfor(let c = 0; c < collections.length; ++c) // Search for all nodes in all journey collections\r\n\t\t\t{\r\n\t\t\t\tconst collection = collections[c];\r\n\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst childNode = collection.words[n];\r\n\t\t\t\t\t\tjourneyNodeObjects.push({node: childNode, collectionIndex: c});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn journeyNodeObjects;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Determines country SVG fill colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n\t * @param d Data attached to DOM element via D3 (i.e. the country).\r\n\t * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n\t */\r\n\tfunction determineFillColour(d)\r\n\t{\r\n\t\tconst nodeObject = findNodes(d, \"cognate\"); // Find node in collections\r\n\t\tif(nodeObject) return nodeObject.node.fillColour;    // Country has associated collection node? Return the colour\r\n\t\telse return \"white\";                             // Otherwise, return white by default for all countries with no associated data\r\n\t}\r\n\t/**\r\n\t * Determines country SVG stroke colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n\t * @param d Data attached to DOM element via D3 (i.e. the country).\r\n\t * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n\t */\r\n\tfunction determineStrokeColour(d)\r\n\t{\r\n\t\tconst nodeObject = findNodes(d, \"cognate\");       // Find node in collections\r\n\t\tif(nodeObject) return nodeObject.node.strokeColour;    // Country has associated collection node? Return the colour\r\n\t\telse return \"black\";                                   // Otherwise, return black by default for all countries with no associated data\r\n\t}\r\n\r\n\r\n\treturn (\r\n\t\t<div className={\"map-container\"}>\r\n\t\t\t<svg\r\n\t\t\t\t/*ref={ref}*/\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\theight: \"100%\",\r\n\t\t\t\t\twidth: \"100%\",\r\n\t\t\t\t\tmargin: 0,\r\n\t\t\t\t\tbackgroundColor: \"#3d73ab\" /* The sea */\r\n\t\t\t\t}}\r\n\t\t\t/>\r\n\t\t</div>\r\n\t);\r\n}\r\n","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\CollectionArea.jsx",["107"],"import {Component} from \"react\";\r\nimport {Collection} from \"./Collection\";\r\nimport {Button} from \"./controls/Button\";\r\nimport {AddEditCollectionModal} from \"./modals/AddEditCollectionModal\";\r\nimport {AddEditNodeModal} from \"./modals/AddEditNodeModal\";\r\n\r\nexport class CollectionArea extends Component\r\n{\r\n\tconstructor(props)\r\n\t{\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t};\r\n\r\n\t\t/* Click, event handlers */\r\n\t\tthis.cAddNode = this.cAddNode.bind(this);\r\n\t\tthis.cAddNodeDefault = this.cAddNodeDefault.bind(this);\r\n\t\tthis.cRemoveCollection = this.cRemoveCollection.bind(this);\r\n\t}\r\n\r\n\t/* Context menu item handlers */\r\n\tcAddNode(e, data)\r\n\t{\r\n\t\t// Open the AddEditNodeModal with initial node data\r\n\t\tconst node = {word: \"\", language: \"\", parents: []};\r\n\t\tif(data.type === \"journey\")\r\n\t\t\tnode.vertex = {type: \"word\", customText: \"\", fontColour: \"#000000\", strokeColour: \"#000000\", fillColour: \"#FFFFFF\", radius: null, fontSize: null, x: null, y: null, edgeStart: \"centre\", edgeEnd: \"centre\", edgeStrokeColour: \"#000000\", edgeStrokeWidth: \"2px\", edgeArrowheadEnabled: true, edgeArrowheadStrokeColour: \"#000000\", edgeArrowheadFillColour: \"#000000\"};\r\n\t\tif(data.type === \"cognate\")\r\n\t\t{\r\n\t\t\tnode.fillColour = \"#FF0000\"; node.strokeColour = \"#000000\";\r\n\t\t\tnode.label = {type: \"word\", customText: \"\", fontColour: \"#000000\", fontSize: null, x: null, y: null};\r\n\t\t}\r\n\t\tthis.props.openModal(e, <AddEditNodeModal isNewWord={true} words={data.words} node={node} type={data.type} onNodeSubmit={this.props.addNode} collectionIndex={data.collectionIndex}/>);\r\n\t}\r\n\tcAddNodeDefault(e, data)\r\n\t{\r\n\t\t// Add node with initial node data\r\n\t\tconst node = {word: \"New Word\", language: \"Proto-Indo-European\", parents: []};\r\n\t\tif(data.type === \"journey\")\r\n\t\t\tnode.vertex = {type: \"word\", customText: \"\", fontColour: \"#000000\", strokeColour: \"#000000\", fillColour: \"#FFFFFF\", radius: null, fontSize: null, x: null, y: null, edgeStart: \"centre\", edgeEnd: \"centre\", edgeStrokeColour: \"#000000\", edgeStrokeWidth: \"2px\", edgeArrowheadEnabled: true, edgeArrowheadStrokeColour: \"#000000\", edgeArrowheadFillColour: \"#000000\"};\r\n\t\tif(data.type === \"cognate\")\r\n\t\t{\r\n\t\t\tnode.strokeColour = \"#000000\";\r\n\t\t\tnode.fillColour = \"#FF0000\";\r\n\t\t\tnode.label = {type: \"language\", customText: \"\", fontColour: \"#000000\", fontSize: null, x: null, y: null};\r\n\t\t}\r\n\r\n\t\tthis.props.addNode(e, data.collectionIndex, node);\r\n\t}\r\n\tcRemoveCollection(e, collectionIndex)\r\n\t{\r\n\t\tthis.props.removeCollection(e, collectionIndex);\r\n\t}\r\n\r\n\r\n\trender()\r\n\t{\r\n\t\tlet journeys, cognates;\r\n\t\tconst journeyCollections = [], cognateCollections = [];\r\n\t\tthis.props.collections.map((collection, index) =>\r\n\t\t{\r\n\t\t\tif(typeof collection !== \"undefined\")\r\n\t\t\t{\r\n\t\t\t\tconst component = <Collection\r\n\t\t\t\t\tcollections={this.props.collections}\r\n\t\t\t\t\tkey={index} index={index} type={collection.type} header={collection.header} openModal={this.props.openModal}\r\n\t\t\t\t\twords={collection.words} editCollection={this.props.editCollection}\r\n\t\t\t\t\topenContextMenu={this.props.openContextMenu} closeContextMenu={this.props.closeContextMenu}\r\n\t\t\t\t\tcAddNode={this.cAddNode} cAddNodeDefault={this.cAddNodeDefault} cRemoveCollection={this.cRemoveCollection}\r\n\t\t\t\t\taddNode={this.props.addNode} editNode={this.props.editNode} removeNode={this.props.removeNode}\r\n\t\t\t\t/>;\r\n\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t\tjourneyCollections.push(component);\r\n\t\t\t\telse if(collection.type === \"cognate\")\r\n\t\t\t\t\tcognateCollections.push(component);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tjourneys =\r\n\t\t\t<>\r\n\t\t\t\t<div className={\"header-container\"}>\r\n\t\t\t\t\t<h3>Journeys</h3>\r\n\t\t\t\t\t<Button value={\"+\"} id={\"manual-add\"} style={{alignSelf: \"end\"}}\r\n\t\t\t\t\t        onClick={(e) => {\r\n\t\t\t\t\t\t        this.props.openModal(e, <AddEditCollectionModal onCollectionSubmit={this.props.addCollection}/>);\r\n\t\t\t\t\t        }}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t\t{journeyCollections}\r\n\t\t\t</>;\r\n\t\tcognates =\r\n\t\t\t<>\r\n\t\t\t\t<div className={\"header-container\"}>\r\n\t\t\t\t\t<h3>Cognates</h3>\r\n\t\t\t\t\t<Button value={\"+\"} id={\"manual-add\"} style={{alignSelf: \"end\"}}\r\n\t\t\t\t\t        onClick={(e) => {\r\n\t\t\t\t\t\t\t\tif(this.props.collections)\r\n\t\t\t\t\t\t        this.props.openModal(e, <AddEditCollectionModal onCollectionSubmit={this.props.addCollection} type={\"cognate\"}/>);\r\n\t\t\t\t\t        }}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t\t{cognateCollections}\r\n\t\t\t</>;\r\n\r\n\t\treturn (\r\n\t\t\t<div className={\"collections-container\"}>\r\n\t\t\t\t<h2>Collection Area</h2>\r\n\t\t\t\t{journeys}\r\n\t\t\t\t{cognates}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\ControlBox.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\ContextMenu.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\AddEditNodeModal.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\Collection.jsx",["108","109"],"import React, {Component} from \"react\";\r\nimport {Meatballs} from \"./controls/Meatballs\";\r\nimport {Collapser} from \"./controls/Collapser\";\r\nimport {AddEditCollectionModal} from \"./modals/AddEditCollectionModal\";\r\nimport {AddEditNodeModal} from \"./modals/AddEditNodeModal\";\r\nimport {Button} from \"./controls/Button\";\r\n\r\nclass CollectionNode extends Component\r\n{\r\n\tconstructor(props)\r\n\t{\r\n\t\tsuper(props);\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\tconst nodeColour = this.props.node.fillColour || this.props.node.vertex.fillColour; // TODO: Advanced logic for determining next unused colour (per journey)\r\n\t\tlet changeColourTimeout;\r\n\t\tconst collectionList = this.props.collections.filter((collection, i) => {\r\n\t\t\tif(collection.type === this.props.type)\r\n\t\t\t{\r\n\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\treturn (\r\n\t\t\t<div className={\"collection-node\"}>\r\n\t\t\t\t{/* Flex-row */}\r\n\t\t\t\t<div onClick={(e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.props.openModal(e, <AddEditNodeModal\r\n\t\t\t\t\t\tcollectionList={collectionList}\r\n\t\t\t\t\t\twords={this.props.words}\r\n\t\t\t\t\t\ttype={this.props.type}\r\n\t\t\t\t\t\tnode={this.props.node}\r\n\t\t\t\t\t\tlanguage={this.props.node.language}\r\n\t\t\t\t\t\tonNodeSubmit={this.props.editNode}\r\n\t\t\t\t\t\tcollectionIndex={this.props.collectionIndex}\r\n\t\t\t\t\t/>);\r\n\t\t\t\t}}>{this.props.node.word}</div>\r\n\t\t\t\t<div onClick={(e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.props.openModal(e, <AddEditNodeModal\r\n\t\t\t\t\t\tcollectionList={collectionList}\r\n\t\t\t\t\t\twords={this.props.words}\r\n\t\t\t\t\t\ttype={this.props.type}\r\n\t\t\t\t\t\tnode={this.props.node}\r\n\t\t\t\t\t\tlanguage={this.props.node.language}\r\n\t\t\t\t\t\tonNodeSubmit={this.props.editNode}\r\n\t\t\t\t\t\tcollectionIndex={this.props.collectionIndex}\r\n\t\t\t\t\t/>);\r\n\t\t\t\t}}>{this.props.node.language}</div>\r\n\t\t\t\t<div className={\"buttons-container\"}>\r\n\t\t\t\t\t<input type={\"color\"} defaultValue={nodeColour} onChange={(e) => {\r\n\t\t\t\t\t\t// Throttle the onChange; there's no way to have it only change when the user clicks off of it, annoyingly\r\n\t\t\t\t\t\tconst node = this;\r\n\t\t\t\t\t\twindow.clearTimeout(changeColourTimeout);\r\n\t\t\t\t\t\tchangeColourTimeout = window.setTimeout(function()\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tconst updatedNode = {\r\n\t\t\t\t\t\t\t\t...node.props.node\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif(node.props.type === \"journey\")\r\n\t\t\t\t\t\t\t\tupdatedNode.vertex.fillColour = e.target.value;\r\n\t\t\t\t\t\t\telse if(node.props.type === \"cognate\")\r\n\t\t\t\t\t\t\t\tupdatedNode.fillColour = e.target.value;\r\n\t\t\t\t\t\t\tnode.props.editNode(e, node.props.collectionIndex, updatedNode);\r\n\t\t\t\t\t\t}, 100);\r\n\t\t\t\t\t}}/>\r\n\t\t\t\t\t<Button value={\"X\"} id={\"remove-node\"}\r\n\t\t\t\t\t        onClick={(e) => this.props.removeNode(e, this.props.collectionIndex, this.props.node.arrayIndex)}/>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport class Collection extends Component\r\n{\r\n\tconstructor(props)\r\n\t{\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tcollapsed: false, // Note: Could be lifted if we want persistence when editing types\r\n\t\t};\r\n\r\n\t\tthis.toggleCollapse = this.toggleCollapse.bind(this);\r\n\t}\r\n\r\n\ttoggleCollapse(e)\r\n\t{\r\n\t\tthis.setState({collapsed: !this.state.collapsed});\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\tconst wordComponents = [];\r\n\t\tconsole.log(this.props);\r\n\r\n\t\tif(!this.state.collapsed)\r\n\t\t{\r\n\t\t\tfor(let i = 0; i < this.props.words.length; ++i)\r\n\t\t\t{\r\n\t\t\t\twordComponents.push(<CollectionNode\r\n\t\t\t\t\tkey={i}\r\n\t\t\t\t\tcollections={this.props.collections}\r\n\t\t\t\t\ttype={this.props.type}\r\n\t\t\t\t\twords={this.props.words}\r\n\t\t\t\t\tnode={this.props.words[i]}\r\n\t\t\t\t\teditNode={this.props.editNode}\r\n\t\t\t\t\tremoveNode={this.props.removeNode}\r\n\t\t\t\t\topenModal={this.props.openModal}\r\n\t\t\t\t\tcollectionIndex={this.props.index}  // Index of collection the node belongs to\r\n\t\t\t\t/>);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst meatballItems = [\r\n\t\t\t{\r\n\t\t\t\ttext: \"Add node\", handler: (e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.props.cAddNode(e, {type: this.props.type, collectionIndex: this.props.index, words: this.props.words});\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttext: \"Add node (default)\", handler: (e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.props.cAddNodeDefault(e, {type: this.props.type, collectionIndex: this.props.index});\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttext: \"Remove collection\", handler: (e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.props.cRemoveCollection(e, this.props.index);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t];\r\n\r\n\t\treturn (\r\n\t\t\t<div className={\"collection-container\"}>\r\n\t\t\t\t<div className={\"collection-header\"}>\r\n\t\t\t\t\t{/* Flex-row */}\r\n\t\t\t\t\t<div onClick={(e) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.props.openModal(e, <AddEditCollectionModal\r\n\t\t\t\t\t\t\ttype={this.props.type}\r\n\t\t\t\t\t\t\tword={this.props.header.word}\r\n\t\t\t\t\t\t\tlanguage={this.props.header.language}\r\n\t\t\t\t\t\t\tonCollectionSubmit={this.props.editCollection}\r\n\t\t\t\t\t\t\tindex={this.props.index}\r\n\t\t\t\t\t\t/>);\r\n\t\t\t\t\t}}>{this.props.header.word}</div>\r\n\t\t\t\t\t<div onClick={(e) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.props.openModal(e, <AddEditCollectionModal\r\n\t\t\t\t\t\t\ttype={this.props.type}\r\n\t\t\t\t\t\t\tword={this.props.header.word}\r\n\t\t\t\t\t\t\tlanguage={this.props.header.language}\r\n\t\t\t\t\t\t\tonCollectionSubmit={this.props.editCollection}\r\n\t\t\t\t\t\t\tindex={this.props.index}\r\n\t\t\t\t\t\t/>);\r\n\t\t\t\t\t}}>{this.props.header.language}</div>\r\n\t\t\t\t\t<div className={\"meatball-collapser-container\"}>\r\n\t\t\t\t\t\t<Meatballs openModal={this.props.openModal} openContextMenu={this.props.openContextMenu}\r\n\t\t\t\t\t\t           closeContextMenu={this.props.closeContextMenu} contextMenuItems={meatballItems}/>\r\n\t\t\t\t\t\t<Collapser toggleCollapse={this.toggleCollapse} collapsed={this.state.collapsed}/>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t{wordComponents}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Textbox.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Button.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\RadioGroup.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\AddEditCollectionModal.jsx",["110"],"import {Component} from \"react\";\r\nimport {Textbox} from \"../controls/Textbox\";\r\nimport {Button} from \"../controls/Button\";\r\nimport {LabeledControl} from \"../controls/LabeledControl\";\r\nimport {ColourPicker} from \"../controls/ColourPicker\";\r\n\r\nexport class AddEditCollectionModal extends Component\r\n{\r\n\tconstructor(props)\r\n\t{\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\ttype: (this.props.type === \"cognate\") ? \"Cognates\" : \"Historical journey\",\r\n\t\t\tword: this.props.word || null,\r\n\t\t\tlanguage: this.props.language || null\r\n\t\t};\r\n\r\n\t\tthis.onCollectionSubmit = this.props.onCollectionSubmit.bind(this);\r\n\t\tthis.onFieldChange = this.onFieldChange.bind(this);\r\n\t\tthis.validation = this.validation.bind(this);\r\n\t}\r\n\r\n\tonFieldChange(event)\r\n\t{\r\n\t\tconst target = event.target;\r\n\t\tconst name = target.name;\r\n\t\tconst value = target.value;\r\n\r\n\t\tthis.setState({\r\n\t\t\t[name]: value\r\n\t\t});\r\n\t}\r\n\r\n\tvalidation()\r\n\t{\r\n\t\t// Data validation\r\n\t\t// TODO: For cognates, only one cognate per language should be allowed\r\n\t\t//  - Future feature: for additional cognate collections, change solid colours to patterns of the specified colours instead (e.g. stripes; checks)\r\n\t\tlet errorCollector = \"\";\r\n\t\tif(this.state.word === null || this.state.word.length <= 0)\r\n\t\t\terrorCollector += \"You must enter a word.\\n\";\r\n\t\tif(this.state.language === null || this.state.language.length <= 0)\r\n\t\t\terrorCollector += \"You must enter a language.\\n\";\r\n\r\n\t\tif(errorCollector.length > 0)\r\n\t\t{\r\n\t\t\talert(errorCollector); // TODO: Proper error handling with toast\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse return true;\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\treturn (\r\n\t\t\t<div className={\"modal\"}>\r\n\t\t\t\t<div className={\"top\"}>\r\n\t\t\t\t\t<div className={\"left\"}>\r\n\t\t\t\t\t\t<h2>New Collection</h2>\r\n\t\t\t\t\t\t<div className={\"node-data\"}>\r\n\t\t\t\t\t\t\t<div className={\"section\"}>\r\n\t\t\t\t\t\t\t\t<div className={\"form\"}>\r\n\t\t\t\t\t\t\t\t\t<LabeledControl label={\"Word: \"}>\r\n\t\t\t\t\t\t\t\t\t\t<Textbox name={\"word\"} value={this.state.word} hint={\"e.g. \\\"horse from PIE to Modern English\\\"\"} onFieldChange={this.onFieldChange} />\r\n\t\t\t\t\t\t\t\t\t</LabeledControl>\r\n\t\t\t\t\t\t\t\t\t<LabeledControl label={\"Language: \"}>\r\n\t\t\t\t\t\t\t\t\t\t<Textbox hint={\"e.g. \\\"English\\\"\"} name={\"language\"} value={this.state.language} onFieldChange={this.onFieldChange} />\r\n\t\t\t\t\t\t\t\t\t</LabeledControl>\r\n\t\t\t\t\t\t\t\t\t<LabeledControl label={\"Type: \"}>\r\n\t\t\t\t\t\t\t\t\t\t<select value={this.state.type} onChange={this.onFieldChange} name={\"type\"}>\r\n\t\t\t\t\t\t\t\t\t\t\t<option>Historical journey</option>\r\n\t\t\t\t\t\t\t\t\t\t\t<option>Cognates</option>\r\n\t\t\t\t\t\t\t\t\t\t</select>\r\n\t\t\t\t\t\t\t\t\t</LabeledControl>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className={\"bottom\"}>\r\n\t\t\t\t\t<div className={\"buttons-container\"}>\r\n\t\t\t\t\t\t<Button value={\"Submit\"} id={\"add-collection-modal-submit\"} onClick={(e) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(this.validation())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tconst type = (this.state.type === \"Historical journey\") ? \"journey\" : \"cognate\";\r\n\t\t\t\t\t\t\t\tconst data = {type: type, header: {word: this.state.word, language: this.state.language}, index: this.props.index};\r\n\t\t\t\t\t\t\t\tthis.props.onCollectionSubmit(e, data);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}}/>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}","D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\ColourPicker.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\LabeledControl.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Meatballs.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\controls\\Collapser.jsx",[],"D:\\xampp\\htdocs\\COMP3000_LEMA\\Project\\lema\\client\\src\\components\\modals\\LoginRegisterModal.jsx",["111","112","113","114","115"],{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","replacedBy":"119"},{"ruleId":"120","severity":1,"message":"121","line":56,"column":9,"nodeType":"122","messageId":"123","endLine":56,"endColumn":19},{"ruleId":"124","severity":1,"message":"125","line":6,"column":2,"nodeType":"126","messageId":"127","endLine":9,"endColumn":3},{"ruleId":"120","severity":1,"message":"128","line":1,"column":27,"nodeType":"122","messageId":"123","endLine":1,"endColumn":35},{"ruleId":"129","severity":1,"message":"130","line":84,"column":67,"nodeType":"131","messageId":"132","endLine":84,"endColumn":69},{"ruleId":"129","severity":1,"message":"130","line":110,"column":67,"nodeType":"131","messageId":"132","endLine":110,"endColumn":69},{"ruleId":"129","severity":1,"message":"130","line":138,"column":66,"nodeType":"131","messageId":"132","endLine":138,"endColumn":68},{"ruleId":"133","severity":1,"message":"134","line":262,"column":29,"nodeType":"135","messageId":"136","endLine":262,"endColumn":31},{"ruleId":"133","severity":1,"message":"134","line":262,"column":49,"nodeType":"135","messageId":"136","endLine":262,"endColumn":51},{"ruleId":"133","severity":1,"message":"137","line":262,"column":49,"nodeType":"135","messageId":"136","endLine":262,"endColumn":51},{"ruleId":"133","severity":1,"message":"137","line":262,"column":69,"nodeType":"135","messageId":"136","endLine":262,"endColumn":71},{"ruleId":"129","severity":1,"message":"130","line":422,"column":67,"nodeType":"131","messageId":"132","endLine":422,"endColumn":69},{"ruleId":"138","severity":1,"message":"139","line":475,"column":18,"nodeType":"131","messageId":"140","endLine":523,"endColumn":7},{"ruleId":"133","severity":1,"message":"134","line":479,"column":28,"nodeType":"135","messageId":"136","endLine":479,"endColumn":30},{"ruleId":"133","severity":1,"message":"134","line":479,"column":48,"nodeType":"135","messageId":"136","endLine":479,"endColumn":50},{"ruleId":"133","severity":1,"message":"137","line":479,"column":48,"nodeType":"135","messageId":"136","endLine":479,"endColumn":50},{"ruleId":"133","severity":1,"message":"137","line":479,"column":68,"nodeType":"135","messageId":"136","endLine":479,"endColumn":70},{"ruleId":"120","severity":1,"message":"141","line":566,"column":9,"nodeType":"122","messageId":"123","endLine":566,"endColumn":19},{"ruleId":"129","severity":1,"message":"142","line":60,"column":50,"nodeType":"131","messageId":"143","endLine":60,"endColumn":52},{"ruleId":"124","severity":1,"message":"125","line":10,"column":2,"nodeType":"126","messageId":"127","endLine":13,"endColumn":3},{"ruleId":"129","severity":1,"message":"130","line":19,"column":72,"nodeType":"131","messageId":"132","endLine":19,"endColumn":74},{"ruleId":"120","severity":1,"message":"144","line":5,"column":9,"nodeType":"122","messageId":"123","endLine":5,"endColumn":21},{"ruleId":"120","severity":1,"message":"144","line":5,"column":9,"nodeType":"122","messageId":"123","endLine":5,"endColumn":21},{"ruleId":"145","severity":1,"message":"146","line":88,"column":14,"nodeType":"147","messageId":"148","endLine":88,"endColumn":15,"suggestions":"149"},{"ruleId":"145","severity":1,"message":"146","line":88,"column":30,"nodeType":"147","messageId":"148","endLine":88,"endColumn":31,"suggestions":"150"},{"ruleId":"151","severity":1,"message":"152","line":151,"column":101,"nodeType":"153","messageId":"154","endLine":151,"endColumn":133,"fix":"155"},{"ruleId":"156","severity":1,"message":"157","line":151,"column":101,"nodeType":"153","endLine":151,"endColumn":133},"no-native-reassign",["158"],"no-negated-in-lhs",["159"],"no-unused-vars","'rememberMe' is assigned a value but never used.","Identifier","unusedVar","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'useState' is defined but never used.","array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'startEdgeXOffset', 'startEdgeYOffset', 'startEdgeXOffset', 'startEdgeYOffset'.","unsafeRefs","'graticules' is assigned a value but never used.","Array.prototype.map() expects a return value from arrow function.","expectedInside","'ColourPicker' is defined but never used.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["160","161"],["162","163"],"react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","JSXOpeningElement","noTargetBlankWithoutNoreferrer",{"range":"164","text":"165"},"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","no-global-assign","no-unsafe-negation",{"messageId":"166","fix":"167","desc":"168"},{"messageId":"169","fix":"170","desc":"171"},{"messageId":"166","fix":"172","desc":"168"},{"messageId":"169","fix":"173","desc":"171"},[5675,5675]," rel=\"noreferrer\"","removeEscape",{"range":"174","text":"175"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"176","text":"177"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"178","text":"175"},{"range":"179","text":"177"},[2445,2446],"",[2445,2445],"\\",[2461,2462],[2461,2461]]