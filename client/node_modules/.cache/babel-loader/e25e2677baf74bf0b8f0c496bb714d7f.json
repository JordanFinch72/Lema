{"ast":null,"code":"var _jsxFileName = \"D:\\\\xampp\\\\htdocs\\\\COMP3000_LEMA\\\\Project\\\\lema\\\\src\\\\components\\\\Map.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { useD3 } from \"../hooks/useD3\";\nimport languageCountries from \"../languageCountries.json\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function Map(props) {\n  _s();\n\n  const items = props.items;\n\n  let topojson = require(\"topojson\");\n\n  let world = require(\"../data/world.json\");\n\n  let foo = [{\n    \"name\": \"Netherlands\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"England\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"Germany\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"England\",\n    \"continent\": \"Europe\"\n  }];\n  useEffect();\n  let ref = useD3(svg => {\n    let width = svg._groups[0][0].clientWidth;\n    let height = svg._groups[0][0].clientHeight;\n    svg.append(\"div\");\n    svg.selectAll(\"div\").data(foo).enter().append(\"div\").text(function (d) {\n      return d.name;\n    });\n    /*let areas = world.features\r\n    \t.reduce((countries2, feature) =>\r\n    \t{\r\n    \t\t// flatten multipolygons into polygons\r\n    \t\tif(feature.geometry.type === \"Polygon\")\r\n    \t\t{\r\n    \t\t\tcountries2.push(feature);\r\n    \t\t}\r\n    \t\telse\r\n    \t\t{ // MultiPolygon\r\n    \t\t\tfeature.geometry.coordinates.forEach(coordinates =>\r\n    \t\t\t{\r\n    \t\t\t\tcountries2.push({\r\n    \t\t\t\t\ttype: \"Feature\",\r\n    \t\t\t\t\tproperties: feature.properties,\r\n    \t\t\t\t\tgeometry: {type: \"Polygon\", coordinates}\r\n    \t\t\t\t});\r\n    \t\t\t});\r\n    \t\t}\r\n    \t\treturn countries2;\r\n    \t}, []);\r\n    \t\t// TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\r\n    const W = width;\r\n    const H = W * height / width;\r\n    const g = svg.append(\"g\");\r\n    const g_countries = g.append(\"g\");\r\n    \t\tconst graticules = g.append(\"path\")\r\n    \t.attr(\"fill\", \"none\")\r\n    \t.attr(\"stroke\", \"rgba(0,0,0,.2)\");\r\n    \t\tlet x = 0;\r\n    let z = 1.7;\r\n    \t\tfunction draw()\r\n    {\r\n    \tconst projection = d3.geoConicConformal()\r\n    \t\t.parallels([40, 68])\r\n    \t\t.rotate([-10 + x / z / 15, 0])\r\n    \t\t.center([8 - 10, 53.823])\r\n    \t\t.scale(900 * z)\r\n    \t\t.translate([W / 2, H / 2]);\r\n    \t\t\tconst path = d3.geoPath().projection(projection);\r\n    \tconst countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\r\n    \tcountries.exit().remove();\r\n    \tconsole.log(countries);\r\n    \tcountries\r\n    \t\t.enter().append(\"path\")\r\n    \t\t.attr(\"fill\", function(d){\r\n    \t\t\t// TODO: Determine fill colour by node colour data\r\n    \t\t\t//  - Need a language->country mapping\r\n    \t\t\t//  - Find node language, get corresponding country, if this d's name is country then change to node colour\r\n    \t\t\t\t\tlet countryName = d.properties.name;\r\n    \t\t\tlet fillColour = \"white\";\r\n    \t\t\t\t\tfor(let collection in items)\r\n    \t\t\t{\r\n    \t\t\t\tif(items.hasOwnProperty(collection))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tcollection = items[collection];\r\n    \t\t\t\t\tif(collection.type === \"cognate\")\r\n    \t\t\t\t\t{\r\n    \t\t\t\t\t\tfor(let childNode in collection.childNodes)\r\n    \t\t\t\t\t\t{\r\n    \t\t\t\t\t\t\tif(collection.childNodes.hasOwnProperty(childNode))\r\n    \t\t\t\t\t\t\t{\r\n    \t\t\t\t\t\t\t\tchildNode = collection.childNodes[childNode];\r\n    \t\t\t\t\t\t\t\tif(languageCountries[childNode.language] === countryName)\r\n    \t\t\t\t\t\t\t\t\tfillColour = childNode.colour;\r\n    \t\t\t\t\t\t\t}\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t\t}\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\treturn fillColour;\r\n    \t\t})\r\n    \t\t.attr(\"stroke\", \"black\")\r\n    \t\t.attr(\"stroke-linejoin\", \"round\")\r\n    \t\t.merge(countries)\r\n    \t\t.attr(\"d\", path);\r\n    \t\t\tgraticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\r\n    }\r\n    \n    /!*\r\n     svg.call(d3.zoom().on(\"zoom\", function () {\r\n     z = d3.event.transform.k;\r\n     draw();\r\n     }));\r\n     *!/\r\n    \t\tdraw();*/\n\n    return svg.node();\n  }, [props.mapRenderCounter]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: ref,\n      style: {\n        height: \"100%\",\n        width: \"100%\",\n        margin: 0\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 4\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 134,\n    columnNumber: 3\n  }, this);\n}\n\n_s(Map, \"/XhorBzwgUVGIC+6eV479yz2RCE=\", false, function () {\n  return [useD3];\n});\n\n_c = Map;\n\nvar _c;\n\n$RefreshReg$(_c, \"Map\");","map":{"version":3,"sources":["D:/xampp/htdocs/COMP3000_LEMA/Project/lema/src/components/Map.jsx"],"names":["React","useState","d3","useD3","languageCountries","Map","props","items","topojson","require","world","foo","useEffect","ref","svg","width","_groups","clientWidth","height","clientHeight","append","selectAll","data","enter","text","d","name","node","mapRenderCounter","margin"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,QAAf,QAA8B,OAA9B;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AACA,SAAQC,KAAR,QAAoB,gBAApB;AACA,OAAOC,iBAAP,MAA8B,2BAA9B;;AAEA,OAAO,SAASC,GAAT,CAAaC,KAAb,EACP;AAAA;;AACC,QAAMC,KAAK,GAAGD,KAAK,CAACC,KAApB;;AACA,MAAIC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAIC,KAAK,GAAGD,OAAO,CAAC,oBAAD,CAAnB;;AAEA,MAAIE,GAAG,GAAG,CAAC;AAAC,YAAQ,aAAT;AAAwB,iBAAa;AAArC,GAAD,EAAiD;AAAC,YAAQ,SAAT;AAAoB,iBAAa;AAAjC,GAAjD,EACT;AAAC,YAAQ,SAAT;AAAoB,iBAAa;AAAjC,GADS,EACmC;AAAC,YAAQ,SAAT;AAAoB,iBAAa;AAAjC,GADnC,CAAV;AAGAC,EAAAA,SAAS;AAET,MAAIC,GAAG,GAAGV,KAAK,CACbW,GAAD,IACA;AACC,QAAIC,KAAK,GAAGD,GAAG,CAACE,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkBC,WAA9B;AACA,QAAIC,MAAM,GAAGJ,GAAG,CAACE,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkBG,YAA/B;AAEAL,IAAAA,GAAG,CAACM,MAAJ,CAAW,KAAX;AACAN,IAAAA,GAAG,CAACO,SAAJ,CAAc,KAAd,EACEC,IADF,CACOX,GADP,EAEEY,KAFF,GAGEH,MAHF,CAGS,KAHT,EAIEI,IAJF,CAIO,UAASC,CAAT,EAAW;AAAC,aAAOA,CAAC,CAACC,IAAT;AAAc,KAJjC;AAMA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAYG,WAAOZ,GAAG,CAACa,IAAJ,EAAP;AAEA,GAhHa,EAiHd,CAACrB,KAAK,CAACsB,gBAAP,CAjHc,CAAf;AAoHA,sBACC;AAAK,IAAA,SAAS,EAAE,eAAhB;AAAA,2BACC;AACC,MAAA,GAAG,EAAEf,GADN;AAEC,MAAA,KAAK,EAAE;AACNK,QAAAA,MAAM,EAAE,MADF;AAENH,QAAAA,KAAK,EAAE,MAFD;AAGNc,QAAAA,MAAM,EAAE;AAHF;AAFR;AAAA;AAAA;AAAA;AAAA;AADD;AAAA;AAAA;AAAA;AAAA,UADD;AAYA;;GA3IexB,G;UAWLF,K;;;KAXKE,G","sourcesContent":["import React, {useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {useD3} from \"../hooks/useD3\";\r\nimport languageCountries from \"../languageCountries.json\";\r\n\r\nexport function Map(props)\r\n{\r\n\tconst items = props.items;\r\n\tlet topojson = require(\"topojson\");\r\n\tlet world = require(\"../data/world.json\");\r\n\r\n\tlet foo = [{\"name\": \"Netherlands\", \"continent\": \"Europe\"}, {\"name\": \"England\", \"continent\": \"Europe\"},\r\n\t\t{\"name\": \"Germany\", \"continent\": \"Europe\"}, {\"name\": \"England\", \"continent\": \"Europe\"}];\r\n\r\n\tuseEffect()\r\n\r\n\tlet ref = useD3(\r\n\t\t(svg) =>\r\n\t\t{\r\n\t\t\tlet width = svg._groups[0][0].clientWidth;\r\n\t\t\tlet height = svg._groups[0][0].clientHeight;\r\n\r\n\t\t\tsvg.append(\"div\");\r\n\t\t\tsvg.selectAll(\"div\")\r\n\t\t\t\t.data(foo)\r\n\t\t\t\t.enter()\r\n\t\t\t\t.append(\"div\")\r\n\t\t\t\t.text(function(d){return d.name});\r\n\r\n\t\t\t/*let areas = world.features\r\n\t\t\t\t.reduce((countries2, feature) =>\r\n\t\t\t\t{\r\n\t\t\t\t\t// flatten multipolygons into polygons\r\n\t\t\t\t\tif(feature.geometry.type === \"Polygon\")\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcountries2.push(feature);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{ // MultiPolygon\r\n\t\t\t\t\t\tfeature.geometry.coordinates.forEach(coordinates =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcountries2.push({\r\n\t\t\t\t\t\t\t\ttype: \"Feature\",\r\n\t\t\t\t\t\t\t\tproperties: feature.properties,\r\n\t\t\t\t\t\t\t\tgeometry: {type: \"Polygon\", coordinates}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn countries2;\r\n\t\t\t\t}, []);\r\n\r\n\t\t\t// TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\r\n\t\t\tconst W = width;\r\n\t\t\tconst H = W * height / width;\r\n\t\t\tconst g = svg.append(\"g\");\r\n\t\t\tconst g_countries = g.append(\"g\");\r\n\r\n\t\t\tconst graticules = g.append(\"path\")\r\n\t\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\");\r\n\r\n\t\t\tlet x = 0;\r\n\t\t\tlet z = 1.7;\r\n\r\n\t\t\tfunction draw()\r\n\t\t\t{\r\n\t\t\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t\t\t.parallels([40, 68])\r\n\t\t\t\t\t.rotate([-10 + x / z / 15, 0])\r\n\t\t\t\t\t.center([8 - 10, 53.823])\r\n\t\t\t\t\t.scale(900 * z)\r\n\t\t\t\t\t.translate([W / 2, H / 2]);\r\n\r\n\t\t\t\tconst path = d3.geoPath().projection(projection);\r\n\t\t\t\tconst countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\r\n\t\t\t\tcountries.exit().remove();\r\n\t\t\t\tconsole.log(countries);\r\n\t\t\t\tcountries\r\n\t\t\t\t\t.enter().append(\"path\")\r\n\t\t\t\t\t.attr(\"fill\", function(d){\r\n\t\t\t\t\t\t// TODO: Determine fill colour by node colour data\r\n\t\t\t\t\t\t//  - Need a language->country mapping\r\n\t\t\t\t\t\t//  - Find node language, get corresponding country, if this d's name is country then change to node colour\r\n\r\n\t\t\t\t\t\tlet countryName = d.properties.name;\r\n\t\t\t\t\t\tlet fillColour = \"white\";\r\n\r\n\t\t\t\t\t\tfor(let collection in items)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(items.hasOwnProperty(collection))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcollection = items[collection];\r\n\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfor(let childNode in collection.childNodes)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tif(collection.childNodes.hasOwnProperty(childNode))\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tchildNode = collection.childNodes[childNode];\r\n\t\t\t\t\t\t\t\t\t\t\tif(languageCountries[childNode.language] === countryName)\r\n\t\t\t\t\t\t\t\t\t\t\t\tfillColour = childNode.colour;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn fillColour;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.attr(\"stroke\", \"black\")\r\n\t\t\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t\t\t.merge(countries)\r\n\t\t\t\t\t.attr(\"d\", path);\r\n\r\n\t\t\t\tgraticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/!*\r\n\t\t\t svg.call(d3.zoom().on(\"zoom\", function () {\r\n\t\t\t z = d3.event.transform.k;\r\n\t\t\t draw();\r\n\t\t\t }));\r\n\t\t\t *!/\r\n\r\n\t\t\tdraw();*/\r\n\r\n\t\t\treturn svg.node();\r\n\r\n\t\t},\r\n\t\t[props.mapRenderCounter]\r\n\t);\r\n\r\n\treturn (\r\n\t\t<div className={\"map-container\"}>\r\n\t\t\t<svg\r\n\t\t\t\tref={ref}\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\theight: \"100%\",\r\n\t\t\t\t\twidth: \"100%\",\r\n\t\t\t\t\tmargin: 0\r\n\t\t\t\t}}>\r\n\t\t\t</svg>\r\n\t\t</div>\r\n\t);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}