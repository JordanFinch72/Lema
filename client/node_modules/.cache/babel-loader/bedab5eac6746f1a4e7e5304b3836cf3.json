{"ast":null,"code":"var _jsxFileName = \"D:\\\\xampp\\\\htdocs\\\\COMP3000_LEMA\\\\Project\\\\lema\\\\src\\\\components\\\\Map.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { useD3 } from \"../hooks/useD3\";\nimport languageCountries from \"../languageCountries.json\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function Map(props) {\n  _s();\n\n  const items = props.items;\n\n  let topojson = require(\"topojson\");\n\n  let world = require(\"../data/world.json\");\n\n  let foo = [{\n    \"name\": \"Netherlands\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"England\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"Germany\",\n    \"continent\": \"Europe\"\n  }, {\n    \"name\": \"France\",\n    \"continent\": \"Europe\"\n  }];\n  /* Functional example of manipulating Map node after it's been constructed */\n  // Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\n\n  useEffect(() => {\n    let innerDiv = d3.selectAll(\".map-container\").append(\"div\");\n    innerDiv.selectAll(\"div\").data(items).text(d => {\n      return d.header.word + \" (\" + d.type + \")\";\n    }).enter().append(\"div\").text(d => {\n      return d.header.word + \" (\" + d.type + \")\";\n    });\n    return function cleanup() {\n      innerDiv.selectAll(\"div\").remove();\n    };\n  });\n  useEffect(() => {\n    let areas = world.features.reduce((countries2, feature) => {\n      // flatten multipolygons into polygons\n      if (feature.geometry.type === \"Polygon\") {\n        countries2.push(feature);\n      } else {\n        // MultiPolygon\n        feature.geometry.coordinates.forEach(coordinates => {\n          countries2.push({\n            type: \"Feature\",\n            properties: feature.properties,\n            geometry: {\n              type: \"Polygon\",\n              coordinates\n            }\n          });\n        });\n      }\n\n      return countries2;\n    }, []); // TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\n\n    const W = width;\n    const H = W * height / width;\n    const g = svg.append(\"g\");\n    const g_countries = g.append(\"g\");\n    const graticules = g.append(\"path\").attr(\"fill\", \"none\").attr(\"stroke\", \"rgba(0,0,0,.2)\");\n    let x = 0;\n    let z = 1.7;\n    const projection = d3.geoConicConformal().parallels([40, 68]).rotate([-10 + x / z / 15, 0]).center([8 - 10, 53.823]).scale(900 * z).translate([W / 2, H / 2]);\n    const path = d3.geoPath().projection(projection);\n    const countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\n    countries.exit().remove();\n    console.log(countries);\n    countries.enter().append(\"path\").attr(\"fill\", function (d) {\n      // TODO: Determine fill colour by node colour data\n      //  - Need a language->country mapping\n      //  - Find node language, get corresponding country, if this d's name is country then change to node colour\n      let countryName = d.properties.name;\n      let fillColour = \"white\";\n\n      for (let collection in items) {\n        if (items.hasOwnProperty(collection)) {\n          collection = items[collection];\n\n          if (collection.type === \"cognate\") {\n            for (let childNode in collection.childNodes) {\n              if (collection.childNodes.hasOwnProperty(childNode)) {\n                childNode = collection.childNodes[childNode];\n                if (languageCountries[childNode.language] === countryName) fillColour = childNode.colour;\n              }\n            }\n          }\n        }\n      }\n\n      return fillColour;\n    }).attr(\"stroke\", \"black\").attr(\"stroke-linejoin\", \"round\").merge(countries).attr(\"d\", path);\n    graticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\n  });\n  /*let ref = useD3(\r\n  \t(svg) =>\r\n  \t{\r\n  \t\tlet width = svg._groups[0][0].clientWidth;\r\n  \t\tlet height = svg._groups[0][0].clientHeight;\r\n  \n  \t\tsvg.append(\"div\");\r\n  \t\tsvg.selectAll(\"div\")\r\n  \t\t\t.data(foo)\r\n  \t\t\t.enter()\r\n  \t\t\t.append(\"div\")\r\n  \t\t\t.text(function(d){return d.name});\r\n  \n  \t\t/!*let areas = world.features\r\n  \t\t\t.reduce((countries2, feature) =>\r\n  \t\t\t{\r\n  \t\t\t\t// flatten multipolygons into polygons\r\n  \t\t\t\tif(feature.geometry.type === \"Polygon\")\r\n  \t\t\t\t{\r\n  \t\t\t\t\tcountries2.push(feature);\r\n  \t\t\t\t}\r\n  \t\t\t\telse\r\n  \t\t\t\t{ // MultiPolygon\r\n  \t\t\t\t\tfeature.geometry.coordinates.forEach(coordinates =>\r\n  \t\t\t\t\t{\r\n  \t\t\t\t\t\tcountries2.push({\r\n  \t\t\t\t\t\t\ttype: \"Feature\",\r\n  \t\t\t\t\t\t\tproperties: feature.properties,\r\n  \t\t\t\t\t\t\tgeometry: {type: \"Polygon\", coordinates}\r\n  \t\t\t\t\t\t});\r\n  \t\t\t\t\t});\r\n  \t\t\t\t}\r\n  \t\t\t\treturn countries2;\r\n  \t\t\t}, []);\r\n  \n  \t\t// TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\r\n  \t\tconst W = width;\r\n  \t\tconst H = W * height / width;\r\n  \t\tconst g = svg.append(\"g\");\r\n  \t\tconst g_countries = g.append(\"g\");\r\n  \n  \t\tconst graticules = g.append(\"path\")\r\n  \t\t\t.attr(\"fill\", \"none\")\r\n  \t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\");\r\n  \n  \t\tlet x = 0;\r\n  \t\tlet z = 1.7;\r\n  \n  \t\tfunction draw()\r\n  \t\t{\r\n  \t\t\tconst projection = d3.geoConicConformal()\r\n  \t\t\t\t.parallels([40, 68])\r\n  \t\t\t\t.rotate([-10 + x / z / 15, 0])\r\n  \t\t\t\t.center([8 - 10, 53.823])\r\n  \t\t\t\t.scale(900 * z)\r\n  \t\t\t\t.translate([W / 2, H / 2]);\r\n  \n  \t\t\tconst path = d3.geoPath().projection(projection);\r\n  \t\t\tconst countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\r\n  \t\t\tcountries.exit().remove();\r\n  \t\t\tconsole.log(countries);\r\n  \t\t\tcountries\r\n  \t\t\t\t.enter().append(\"path\")\r\n  \t\t\t\t.attr(\"fill\", function(d){\r\n  \t\t\t\t\t// TODO: Determine fill colour by node colour data\r\n  \t\t\t\t\t//  - Need a language->country mapping\r\n  \t\t\t\t\t//  - Find node language, get corresponding country, if this d's name is country then change to node colour\r\n  \n  \t\t\t\t\tlet countryName = d.properties.name;\r\n  \t\t\t\t\tlet fillColour = \"white\";\r\n  \n  \t\t\t\t\tfor(let collection in items)\r\n  \t\t\t\t\t{\r\n  \t\t\t\t\t\tif(items.hasOwnProperty(collection))\r\n  \t\t\t\t\t\t{\r\n  \t\t\t\t\t\t\tcollection = items[collection];\r\n  \t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n  \t\t\t\t\t\t\t{\r\n  \t\t\t\t\t\t\t\tfor(let childNode in collection.childNodes)\r\n  \t\t\t\t\t\t\t\t{\r\n  \t\t\t\t\t\t\t\t\tif(collection.childNodes.hasOwnProperty(childNode))\r\n  \t\t\t\t\t\t\t\t\t{\r\n  \t\t\t\t\t\t\t\t\t\tchildNode = collection.childNodes[childNode];\r\n  \t\t\t\t\t\t\t\t\t\tif(languageCountries[childNode.language] === countryName)\r\n  \t\t\t\t\t\t\t\t\t\t\tfillColour = childNode.colour;\r\n  \t\t\t\t\t\t\t\t\t}\r\n  \t\t\t\t\t\t\t\t}\r\n  \t\t\t\t\t\t\t}\r\n  \t\t\t\t\t\t}\r\n  \t\t\t\t\t}\r\n  \t\t\t\t\treturn fillColour;\r\n  \t\t\t\t})\r\n  \t\t\t\t.attr(\"stroke\", \"black\")\r\n  \t\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n  \t\t\t\t.merge(countries)\r\n  \t\t\t\t.attr(\"d\", path);\r\n  \n  \t\t\tgraticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\r\n  \t\t}\r\n  \n  \n  \t\t/!*\r\n  \t\t svg.call(d3.zoom().on(\"zoom\", function () {\r\n  \t\t z = d3.event.transform.k;\r\n  \t\t draw();\r\n  \t\t }));\r\n  \t\t *!/\r\n  \n  \t\tdraw();*!/\r\n  \n  \t\treturn svg.node();\r\n  \n  \t},\r\n  \t[props.mapRenderCounter]\r\n  );*/\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"map-container\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 243,\n    columnNumber: 3\n  }, this);\n}\n\n_s(Map, \"3ubReDTFssvu4DHeldAg55cW/CI=\");\n\n_c = Map;\n\nvar _c;\n\n$RefreshReg$(_c, \"Map\");","map":{"version":3,"sources":["D:/xampp/htdocs/COMP3000_LEMA/Project/lema/src/components/Map.jsx"],"names":["React","useEffect","useState","d3","useD3","languageCountries","Map","props","items","topojson","require","world","foo","innerDiv","selectAll","append","data","text","d","header","word","type","enter","cleanup","remove","areas","features","reduce","countries2","feature","geometry","push","coordinates","forEach","properties","W","width","H","height","g","svg","g_countries","graticules","attr","x","z","projection","geoConicConformal","parallels","rotate","center","scale","translate","path","geoPath","countries","exit","console","log","countryName","name","fillColour","collection","hasOwnProperty","childNode","childNodes","language","colour","merge","geoGraticule","step"],"mappings":"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CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC,sBACC;AAAK,IAAA,SAAS,EAAE;AAAhB;AAAA;AAAA;AAAA;AAAA,UADD;AAYA;;GAxPehE,G;;KAAAA,G","sourcesContent":["import React, {useEffect, useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {useD3} from \"../hooks/useD3\";\r\nimport languageCountries from \"../languageCountries.json\";\r\n\r\nexport function Map(props)\r\n{\r\n\tconst items = props.items;\r\n\tlet topojson = require(\"topojson\");\r\n\tlet world = require(\"../data/world.json\");\r\n\r\n\tlet foo = [{\"name\": \"Netherlands\", \"continent\": \"Europe\"}, {\"name\": \"England\", \"continent\": \"Europe\"},\r\n\t\t{\"name\": \"Germany\", \"continent\": \"Europe\"}, {\"name\": \"France\", \"continent\": \"Europe\"}];\r\n\r\n\t/* Functional example of manipulating Map node after it's been constructed */\r\n\t// Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\r\n\tuseEffect(() => {\r\n\t\tlet innerDiv = d3.selectAll(\".map-container\").append(\"div\");\r\n\t\tinnerDiv\r\n\t\t\t.selectAll(\"div\")\r\n\t\t\t.data(items)\r\n\t\t\t.text((d) => {\r\n\t\t\t\treturn d.header.word + \" (\" + d.type + \")\";\r\n\t\t\t})\r\n\t\t\t.enter()\r\n\t\t\t.append(\"div\")\r\n\t\t\t.text((d) => {\r\n\t\t\t\treturn d.header.word + \" (\" + d.type + \")\";\r\n\t\t\t});\r\n\r\n\t\treturn function cleanup()\r\n\t\t{\r\n\t\t\tinnerDiv\r\n\t\t\t\t.selectAll(\"div\")\r\n\t\t\t\t.remove();\r\n\t\t}\r\n\t})\r\n\r\n\tuseEffect(() => {\r\n\t\tlet areas = world.features\r\n\t\t\t.reduce((countries2, feature) =>\r\n\t\t\t{\r\n\t\t\t\t// flatten multipolygons into polygons\r\n\t\t\t\tif(feature.geometry.type === \"Polygon\")\r\n\t\t\t\t{\r\n\t\t\t\t\tcountries2.push(feature);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{ // MultiPolygon\r\n\t\t\t\t\tfeature.geometry.coordinates.forEach(coordinates =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcountries2.push({\r\n\t\t\t\t\t\t\ttype: \"Feature\",\r\n\t\t\t\t\t\t\tproperties: feature.properties,\r\n\t\t\t\t\t\t\tgeometry: {type: \"Polygon\", coordinates}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn countries2;\r\n\t\t\t}, []);\r\n\r\n\t\t// TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\r\n\t\tconst W = width;\r\n\t\tconst H = W * height / width;\r\n\t\tconst g = svg.append(\"g\");\r\n\t\tconst g_countries = g.append(\"g\");\r\n\r\n\t\tconst graticules = g.append(\"path\")\r\n\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\");\r\n\r\n\t\tlet x = 0;\r\n\t\tlet z = 1.7;\r\n\r\n\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t.parallels([40, 68])\r\n\t\t\t.rotate([-10 + x / z / 15, 0])\r\n\t\t\t.center([8 - 10, 53.823])\r\n\t\t\t.scale(900 * z)\r\n\t\t\t.translate([W / 2, H / 2]);\r\n\r\n\t\tconst path = d3.geoPath().projection(projection);\r\n\t\tconst countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\r\n\t\tcountries.exit().remove();\r\n\t\tconsole.log(countries);\r\n\t\tcountries\r\n\t\t\t.enter().append(\"path\")\r\n\t\t\t.attr(\"fill\", function(d){\r\n\t\t\t\t// TODO: Determine fill colour by node colour data\r\n\t\t\t\t//  - Need a language->country mapping\r\n\t\t\t\t//  - Find node language, get corresponding country, if this d's name is country then change to node colour\r\n\r\n\t\t\t\tlet countryName = d.properties.name;\r\n\t\t\t\tlet fillColour = \"white\";\r\n\r\n\t\t\t\tfor(let collection in items)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(items.hasOwnProperty(collection))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcollection = items[collection];\r\n\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfor(let childNode in collection.childNodes)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif(collection.childNodes.hasOwnProperty(childNode))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tchildNode = collection.childNodes[childNode];\r\n\t\t\t\t\t\t\t\t\tif(languageCountries[childNode.language] === countryName)\r\n\t\t\t\t\t\t\t\t\t\tfillColour = childNode.colour;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn fillColour;\r\n\t\t\t})\r\n\t\t\t.attr(\"stroke\", \"black\")\r\n\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t.merge(countries)\r\n\t\t\t.attr(\"d\", path);\r\n\r\n\t\tgraticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\r\n\r\n\t});\r\n\r\n\t/*let ref = useD3(\r\n\t\t(svg) =>\r\n\t\t{\r\n\t\t\tlet width = svg._groups[0][0].clientWidth;\r\n\t\t\tlet height = svg._groups[0][0].clientHeight;\r\n\r\n\t\t\tsvg.append(\"div\");\r\n\t\t\tsvg.selectAll(\"div\")\r\n\t\t\t\t.data(foo)\r\n\t\t\t\t.enter()\r\n\t\t\t\t.append(\"div\")\r\n\t\t\t\t.text(function(d){return d.name});\r\n\r\n\t\t\t/!*let areas = world.features\r\n\t\t\t\t.reduce((countries2, feature) =>\r\n\t\t\t\t{\r\n\t\t\t\t\t// flatten multipolygons into polygons\r\n\t\t\t\t\tif(feature.geometry.type === \"Polygon\")\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcountries2.push(feature);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{ // MultiPolygon\r\n\t\t\t\t\t\tfeature.geometry.coordinates.forEach(coordinates =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcountries2.push({\r\n\t\t\t\t\t\t\t\ttype: \"Feature\",\r\n\t\t\t\t\t\t\t\tproperties: feature.properties,\r\n\t\t\t\t\t\t\t\tgeometry: {type: \"Polygon\", coordinates}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn countries2;\r\n\t\t\t\t}, []);\r\n\r\n\t\t\t// TODO: Adjust dimensions so it displays better; have it auto-scale as window is dragged\r\n\t\t\tconst W = width;\r\n\t\t\tconst H = W * height / width;\r\n\t\t\tconst g = svg.append(\"g\");\r\n\t\t\tconst g_countries = g.append(\"g\");\r\n\r\n\t\t\tconst graticules = g.append(\"path\")\r\n\t\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\");\r\n\r\n\t\t\tlet x = 0;\r\n\t\t\tlet z = 1.7;\r\n\r\n\t\t\tfunction draw()\r\n\t\t\t{\r\n\t\t\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t\t\t.parallels([40, 68])\r\n\t\t\t\t\t.rotate([-10 + x / z / 15, 0])\r\n\t\t\t\t\t.center([8 - 10, 53.823])\r\n\t\t\t\t\t.scale(900 * z)\r\n\t\t\t\t\t.translate([W / 2, H / 2]);\r\n\r\n\t\t\t\tconst path = d3.geoPath().projection(projection);\r\n\t\t\t\tconst countries = svg.append(\"g\").append(\"g\").selectAll(\"path\").data(areas);\r\n\t\t\t\tcountries.exit().remove();\r\n\t\t\t\tconsole.log(countries);\r\n\t\t\t\tcountries\r\n\t\t\t\t\t.enter().append(\"path\")\r\n\t\t\t\t\t.attr(\"fill\", function(d){\r\n\t\t\t\t\t\t// TODO: Determine fill colour by node colour data\r\n\t\t\t\t\t\t//  - Need a language->country mapping\r\n\t\t\t\t\t\t//  - Find node language, get corresponding country, if this d's name is country then change to node colour\r\n\r\n\t\t\t\t\t\tlet countryName = d.properties.name;\r\n\t\t\t\t\t\tlet fillColour = \"white\";\r\n\r\n\t\t\t\t\t\tfor(let collection in items)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(items.hasOwnProperty(collection))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcollection = items[collection];\r\n\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfor(let childNode in collection.childNodes)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tif(collection.childNodes.hasOwnProperty(childNode))\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tchildNode = collection.childNodes[childNode];\r\n\t\t\t\t\t\t\t\t\t\t\tif(languageCountries[childNode.language] === countryName)\r\n\t\t\t\t\t\t\t\t\t\t\t\tfillColour = childNode.colour;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn fillColour;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.attr(\"stroke\", \"black\")\r\n\t\t\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t\t\t.merge(countries)\r\n\t\t\t\t\t.attr(\"d\", path);\r\n\r\n\t\t\t\tgraticules.attr(\"d\", path(d3.geoGraticule().step([20, 20])()));\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/!*\r\n\t\t\t svg.call(d3.zoom().on(\"zoom\", function () {\r\n\t\t\t z = d3.event.transform.k;\r\n\t\t\t draw();\r\n\t\t\t }));\r\n\t\t\t *!/\r\n\r\n\t\t\tdraw();*!/\r\n\r\n\t\t\treturn svg.node();\r\n\r\n\t\t},\r\n\t\t[props.mapRenderCounter]\r\n\t);*/\r\n\r\n\treturn (\r\n\t\t<div className={\"map-container\"}>\r\n\t\t\t{/*<svg\r\n\t\t\t\tref={ref}\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\theight: \"100%\",\r\n\t\t\t\t\twidth: \"100%\",\r\n\t\t\t\t\tmargin: 0\r\n\t\t\t\t}}>\r\n\t\t\t</svg>*/}\r\n\t\t</div>\r\n\t);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}