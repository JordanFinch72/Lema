{"ast":null,"code":"var _jsxFileName = \"D:\\\\xampp\\\\htdocs\\\\COMP3000_LEMA\\\\client\\\\src\\\\components\\\\Map.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport { AddEditNodeModal } from \"./modals/AddEditNodeModal\";\nimport { ContextMenu } from \"./controls/ContextMenu\";\nimport countriesData from \"../data/countries/countries.json\";\nimport languageProperties from \"../data/languageProperties.json\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function Map(props) {\n  _s();\n\n  // DEBUG MODE\n  const DEBUG_MODE = false;\n  if (DEBUG_MODE) console.debug(\"[== MAP RENDER ==]\"); // Prop functions\n\n  const openContextMenu = props.openContextMenu.bind(this);\n  const addNode = props.addNode.bind(this);\n  const editNode = props.editNode.bind(this);\n  const removeNode = props.removeNode.bind(this);\n  const openModal = props.openModal.bind(this);\n  const createToast = props.createToast.bind(this); // Props\n\n  const collections = props.collections; // Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\n\n  useEffect(() => {\n    const svg = d3.selectAll(\".map-container\").selectAll(\"svg\");\n    const countries = countriesData.features; // Create path (passed as svg attribute later to draw the countries)\n    // TODO: Have it auto-scale as window is dragged/re-sized\n\n    const width = svg._groups[0][0].clientWidth;\n    const height = svg._groups[0][0].clientHeight;\n    const projection = d3.geoConicConformal().center([8, 52.823]) // Middle of Europe(ish)\n    .scale(1650).translate([width / 2, height / 2]);\n    const path = d3.geoPath().projection(projection);\n    svg.on(\"drag\", e => {\n      console.log(e);\n    });\n    let svgChildren = null,\n        svgXInit = 0,\n        svgYInit = 0,\n        svgXOffset = 0,\n        svgYOffset = 0;\n    svg.call(d3.drag().on(\"start\", e => {\n      svgChildren = d3.selectAll(\"svg#map-svg g\");\n      console.log(e);\n    }).on(\"drag\", e => {\n      // TODO: Determine drag direction\n      console.log(svgChildren);\n      svgXOffset -= 10;\n      svgChildren.attr(\"style\", `transform: translate(${svgXOffset}px, ${svgYOffset}px)`);\n    }));\n    let coordGroup;\n\n    if (DEBUG_MODE) {\n      coordGroup = svg.append(\"g\").classed(\"coords\", true).attr('transform', 'translate(50,150)');\n    } // Draw countries, bind data and handlers\n\n\n    const countryPaths = svg.append(\"g\").selectAll(\"path\") // svg->g->path\n    .data(countries) // svg->g->path\n    .enter() // svg->g->path (create new nodes per data)\n    .append(\"path\") // svg->g->path (create new nodes per data)\n    .attr(\"fill\", d => determineFillColour(d)).attr(\"stroke\", d => determineStrokeColour(d)).attr(\"stroke-linejoin\", \"round\").attr(\"d\", path).on(\"click\", function (e, d) {\n      // TODO: Possibly same functions as context menu (see about calling this.onContextMenu() to keep things nice and DRY)\n      createToast(e, d.properties.name_long, 2000);\n    }).on(\"mousemove\", function (e, d) {\n      if (DEBUG_MODE) {\n        const x = e.offsetX - 612,\n              y = e.offsetY - 528;\n        coordGroup.selectAll(\"text\").remove();\n        coordGroup.append(\"text\").text(`(${x},${y})`).attr(\"fill\", \"white\");\n      }\n    }).on(\"contextmenu\", function (e, d) {\n      e.preventDefault(); // Prevent browser context menu from opening\n\n      const nodeObject = findNodes(d, \"cognate\");\n      let contextMenuItems = []; // If clicked-on country has attached cognate\n\n      if (nodeObject) {\n        contextMenuItems = [{\n          text: \"Edit node (cognate)\",\n          handler: e => {\n            const collectionList = collections.filter((collection, i) => {\n              if (collection.type === \"cognate\") {\n                collection.collectionIndex = i;\n                return true;\n              }\n            });\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: editNode,\n              node: nodeObject.node,\n              collectionList: collectionList,\n              collectionIndex: nodeObject.collectionIndex,\n              type: \"cognate\",\n              language: nodeObject.node.language\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 111,\n              columnNumber: 22\n            }, this));\n          }\n        }, {\n          text: \"Remove node (cognate)\",\n          handler: e => {\n            removeNode(e, nodeObject.collectionIndex, nodeObject.arrayIndex);\n          }\n        }];\n      } else {\n        // TODO: Context menu for adding to new collection, adding to existing collection\n        contextMenuItems = [{\n          text: \"Add country to collection (cognate)\",\n          handler: e => {\n            const collectionList = collections.filter((collection, i) => {\n              if (collection.type === \"cognate\") {\n                collection.collectionIndex = i;\n                return true;\n              }\n            });\n\n            if (collectionList.length <= 0) {\n              createToast(e, \"You must first create a cognate collection for the node to be added to.\");\n            } else {\n              const node = {\n                word: \"\",\n                language: \"\",\n                parents: []\n              };\n              node.fillColour = \"#FF0000\";\n              node.strokeColour = \"#000000\";\n              node.label = {\n                type: \"word\",\n                customText: \"\",\n                fontColour: \"#000000\",\n                fontSize: null,\n                x: null,\n                y: null\n              };\n              openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n                isNewWord: true,\n                onNodeSubmit: addNode,\n                node: node,\n                type: \"cognate\",\n                collectionList: collectionList,\n                collectionIndex: collectionList[0].collectionIndex,\n                language: d.properties.languages\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 146,\n                columnNumber: 23\n              }, this));\n            }\n          }\n        }];\n      } // Common to both\n\n\n      contextMenuItems.unshift({\n        text: \"Add new node (journey)\",\n        handler: e => {\n          const collectionList = collections.filter((collection, i) => {\n            if (collection.type === \"journey\") {\n              collection.collectionIndex = i;\n              return true;\n            }\n          });\n\n          if (collectionList.length <= 0) {\n            createToast(e, \"You must first create a journey collection for the node to be added to.\");\n          } else {\n            // Open the AddEditNodeModal with initial node data\n            const node = {\n              word: \"\",\n              language: d.properties.languages[0],\n              parents: []\n            };\n            node.vertex = {\n              type: \"word\",\n              customText: \"\",\n              fontColour: \"#000000\",\n              strokeColour: \"#000000\",\n              fillColour: \"#FFFFFF\",\n              radius: null,\n              fontSize: null,\n              x: null,\n              y: null,\n              edgeStart: \"centre\",\n              edgeEnd: \"centre\",\n              edgeStrokeColour: \"#000000\",\n              edgeStrokeWidth: \"2px\",\n              edgeArrowheadEnabled: true,\n              edgeArrowheadStrokeColour: \"#000000\",\n              edgeArrowheadFillColour: \"#000000\"\n            };\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              isNewWord: true,\n              node: node,\n              type: \"journey\",\n              onNodeSubmit: addNode,\n              collectionList: collectionList,\n              collectionIndex: collectionList[0].collectionIndex,\n              language: d.properties.languages\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 173,\n              columnNumber: 22\n            }, this));\n          }\n        }\n      });\n      openContextMenu(e, /*#__PURE__*/_jsxDEV(ContextMenu, {\n        x: e.clientX,\n        y: e.clientY,\n        items: contextMenuItems\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 178,\n        columnNumber: 24\n      }, this));\n    }).on(\"mouseover\", function (e, d) {\n      const element = d3.select(this);\n      if (element.attr(\"fill\") === \"white\") // White can't become transparent\n        element.attr(\"fill\", \"rgb(230,230,230)\");else element.attr(\"fill-opacity\", \"0.65\");\n    }).on(\"mouseout\", function (e, d) {\n      const element = d3.select(this);\n      if (element.attr(\"fill\") === \"rgb(230,230,230)\") // Reset white\n        element.attr(\"fill\", \"white\");else element.attr(\"fill-opacity\", \"1\");\n    }); // Cognate labels, journey vertices\n\n    const edgesGroup = svg.append(\"g\").classed(\"edges\", true); // SVG group for edges\n\n    edgesGroup.on(\"contextmenu\", e => e.preventDefault());\n    const verticesLabelsGroup = svg.append(\"g\").classed(\"vertices-labels\", true); // SVG group for vertices AND cognate labels\n\n    countryPaths.each(function (f, i) {\n      const cognateNodeObject = findNodes(f, \"cognate\"); // The first node in any cognate collection that belongs to this country/region\n\n      if (cognateNodeObject) {\n        /* Cognate visualisations */\n        const node = cognateNodeObject.node;\n        const languageProp = getLanguageProp(node);\n        const boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\n\n        let fontSize = node.label.fontSize; // Font size of the label\n\n        let labelText = node.word; // Word by default\n\n        if (node.label.type === \"Country/region\") labelText = f.properties.name_long;else if (node.label.type === \"Custom text\") labelText = node.label.customText;else if (node.label.type === \"Language\") labelText = node.language; // Initial scale factor depending on size of country (to stop oversized text from escaping country)\n\n        if (labelText.length !== 0 && !node.label.fontSize) // Only scale if font size hasn't been set by user\n          {\n            if (boundingBox.width < labelText.length * 16) fontSize = boundingBox.width / 8 + \"px\";\n          } // Initial co-ordinates\n\n\n        let x = node.label.x === null ? languageProp.x + 612 : node.label.x;\n        let y = node.label.y === null ? languageProp.y + 528 : node.label.y;\n        const label = verticesLabelsGroup.append(\"text\").attr(\"x\", x).attr(\"y\", y).attr(\"fill\", node.label.fontColour).attr(\"font-family\", \"'Segoe UI', sans-serif\").style(\"font-size\", fontSize).text(labelText); // Dragging/resizing handlers\n\n        let startXOffset,\n            startYOffset,\n            resizing = false,\n            startX,\n            startY,\n            startSize,\n            newSize;\n        label.on(\"mousemove\", e => {\n          const labelX = parseFloat(label.attr(\"x\")),\n                labelY = parseFloat(label.attr(\"y\"));\n          const mouseX = e.layerX,\n                mouseY = e.layerY; // Determine corner of text's box\n\n          const southEastCorner = {\n            xStart: labelX + label.node().getBBox().width - 5,\n            xEnd: labelX + label.node().getBBox().width + 15,\n            yStart: labelY,\n            yEnd: labelY + 10\n          }; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n            label.style(\"cursor\", \"se-resize\");\n          } else label.style(\"cursor\", \"grab\");\n        }).call(d3.drag().on(\"start\", e => {\n          const labelX = parseFloat(label.attr(\"x\")),\n                labelY = parseFloat(label.attr(\"y\"));\n          const mouseX = e.x,\n                mouseY = e.y;\n          startXOffset = mouseX - labelX;\n          startYOffset = mouseY - labelY; // Determine corner of text's box\n\n          const southEastCorner = {\n            xStart: labelX + label.node().getBBox().width - 5,\n            xEnd: labelX + label.node().getBBox().width + 15,\n            yStart: labelY,\n            yEnd: labelY + 10\n          }; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n            resizing = true;\n            startX = mouseX;\n            startY = mouseY;\n            startSize = parseFloat(label.style(\"font-size\"));\n          }\n        }).on(\"drag\", e => {\n          const mouseX = e.x,\n                mouseY = e.y;\n\n          if (resizing) {\n            // Resize the label\n            if (mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY) {\n              const deltaX = mouseX - startX;\n              newSize = startSize + deltaX / 10;\n              if (newSize < 5) newSize = 5; // Floor of 5px to prevent it shrinking into nothingness\n\n              label.style(\"font-size\", newSize + \"px\"); // Only visually, not updating state itself\n            }\n          } else {\n            // Move the label\n            x = mouseX - startXOffset;\n            y = mouseY - startYOffset;\n            newSize = node.label.fontSize;\n            label.attr(\"x\", x).attr(\"y\", y); // Only visually\n          }\n        }).on(\"end\", () => {\n          resizing = false;\n          node.label.x = x;\n          node.label.y = y;\n          node.label.fontSize = newSize;\n          editNode(null, cognateNodeObject.collectionIndex, node);\n        }));\n      }\n    }); // Journeys\n\n    const journeyNodeObjects = findNodes(null, \"journey\");\n\n    if (journeyNodeObjects) {\n      /* Journey visualisations */\n      // Loop through all journey nodes inside this country/region\n      let startEdgeXOffset = 0,\n          startEdgeYOffset = 0,\n          endEdgeXOffset = 0,\n          endEdgeYOffset = 0; // Centre by default\n\n      for (let i = 0; i < journeyNodeObjects.length; ++i) {\n        const journeyNodeObject = journeyNodeObjects[i];\n        const node = journeyNodeObject.node;\n        const languageProp = getLanguageProp(node);\n        let radius = node.vertex.radius || languageProp.radius || 50; // Inherit radius (determined later if null)\n\n        const fontSize = node.vertex.fontSize;\n        let vertexText = node.word; // Word by default\n\n        if (node.vertex.type === \"Custom text\") vertexText = node.vertex.customText;else if (node.vertex.type === \"Language\") vertexText = node.language;\n        /* Build node elements - VERTEX */\n        // Initial co-ordinates\n\n        let vertexX = node.vertex.x === null ? languageProp.x + 612 : node.vertex.x;\n        let vertexY = node.vertex.y === null ? languageProp.y + 528 : node.vertex.y; // Set initial vertex position\n\n        if (!node.vertex.x || !node.vertex.y) {\n          node.vertex.x = vertexX;\n          node.vertex.y = vertexY;\n          return editNode(null, journeyNodeObject.collectionIndex, node); // Performance TODO: Make this a bulk update instead to prevent re-rendering loop\n        } // Prepare text element. This is required to calculate circle radius based on text element's width\n\n\n        const vertexG = verticesLabelsGroup.append(\"g\"); // Group required to have circle and text together\n\n        const preparedText = vertexG.append(\"text\").attr(\"x\", vertexX).attr(\"y\", vertexY).attr(\"fill\", node.vertex.fontColour).attr(\"text-anchor\", \"middle\") // Centre of circle\n        .attr(\"alignment-baseline\", \"middle\") // Centre of circle\n        .attr(\"font-family\", \"'Segoe UI', sans-serif\").style(\"font-size\", \"16px\").text(vertexText); // Determine initial radius of circle\n\n        const innerTextWidth = preparedText.node().getBBox().width;\n\n        if (vertexText.length !== 0 && !node.vertex.radius) // Only scale if font size hasn't been set by user\n          {\n            if (radius < innerTextWidth) radius = innerTextWidth / 2 + 5; // Convert text \"diameter\" to radius, add padding\n          }\n\n        preparedText.remove(); // Remove prepared text element. It will not show if appended before the circle\n\n        /* Build node elements - EDGE */\n        // Place edge between this node and its parents\n\n        let markerSelectString = \"\"; // String to select markers so that they can move whilst being resized\n\n        if (node.parents) {\n          // Create edge for each parent, originating from this node\n          for (let i = 0; i < node.parents.length; ++i) {\n            const parentNode = node.parents[i]; // Fingerprint references for marker IDs and data-start/data-end attributes\n\n            const parentRef = journeyNodeObject.collectionIndex + \"|\" + parentNode.arrayIndex;\n            const nodeRef = journeyNodeObject.collectionIndex + \"|\" + node.arrayIndex; // Compute arrowheads\n\n            if (node.vertex.edgeArrowheadEnabled) {\n              edgesGroup.append(\"defs\").append(\"marker\").attr(\"id\", \"arrow\" + parentRef + nodeRef).attr(\"markerWidth\", 5).attr(\"markerHeight\", 4).attr(\"refX\", radius / 2 + 5).attr(\"refY\", 2).attr(\"orient\", \"auto\").append(\"polygon\").attr(\"points\", \"0 0, 5 2, 0 4\").attr(\"fill\", node.vertex.edgeArrowheadFillColour).attr(\"stroke\", node.vertex.edgeArrowheadStrokeColour).attr(\"id\", nodeRef);\n              markerSelectString += \"marker[id=\\\"arrow\" + parentRef + nodeRef + \"\\\"], \";\n            } // Determine edge start position\n\n\n            if (node.vertex.edgeStart === \"top\") startEdgeYOffset = -radius;else if (node.vertex.edgeStart === \"right\") startEdgeXOffset = radius;else if (node.vertex.edgeStart === \"bottom\") startEdgeYOffset = radius;else if (node.vertex.edgeStart === \"left\") startEdgeXOffset = -radius;else if (node.vertex.edgeStart === \"centre\") {\n              startEdgeXOffset = 0;\n              startEdgeYOffset = 0;\n            } // Determine edge end position\n\n            if (node.vertex.edgeEnd === \"top\") endEdgeYOffset = -radius;else if (node.vertex.edgeEnd === \"right\") endEdgeXOffset = radius;else if (node.vertex.edgeEnd === \"bottom\") endEdgeYOffset = radius;else if (node.vertex.edgeEnd === \"left\") endEdgeXOffset = -radius;else if (node.vertex.edgeStart === \"centre\") {\n              endEdgeXOffset = 0;\n              endEdgeYOffset = 0;\n            } // Place edge\n\n            const edge = edgesGroup.append(\"line\").attr(\"x1\", parentNode.vertex.x + startEdgeXOffset).attr(\"y1\", parentNode.vertex.y + startEdgeYOffset).attr(\"x2\", node.vertex.x + endEdgeXOffset).attr(\"y2\", node.vertex.y + endEdgeYOffset).attr(\"stroke\", node.vertex.edgeStrokeColour).attr(\"stroke-width\", node.vertex.edgeStrokeWidth).attr(\"data-start\", parentRef) // For finding attached edges later\n            .attr(\"data-end\", nodeRef);\n            if (node.vertex.edgeArrowheadEnabled) edge.attr(\"marker-end\", \"url(#arrow\" + parentRef + nodeRef + \")\");\n          }\n        } // Place node elements\n\n\n        const vertex = vertexG.append(\"circle\").attr(\"cx\", vertexX).attr(\"cy\", vertexY).attr(\"r\", radius + \"px\").attr(\"stroke\", node.vertex.strokeColour).attr(\"fill\", node.vertex.fillColour);\n        const text = vertexG.append(\"text\").attr(\"x\", vertexX).attr(\"y\", vertexY).attr(\"fill\", node.vertex.fontColour).attr(\"text-anchor\", \"middle\") // Centre of circle\n        .attr(\"alignment-baseline\", \"middle\") // Centre of circle\n        .attr(\"font-family\", \"'Segoe UI', sans-serif\").style(\"font-size\", fontSize).text(vertexText);\n        /* Dragging/resizing/clicking handlers */\n\n        let startXOffset,\n            startYOffset,\n            resizing = false,\n            startX,\n            startY,\n            startRadius,\n            newVertexRadius,\n            newLabelSize;\n\n        const nodeContextMenuHandler = e => {\n          e.preventDefault();\n          const contextMenuItems = [{\n            text: \"Edit node\",\n            handler: e => {\n              const collectionList = collections.filter((collection, i) => {\n                if (collection.type === \"journey\") {\n                  collection.collectionIndex = i;\n                  return true;\n                }\n              });\n              openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n                onNodeSubmit: editNode,\n                node: node,\n                collectionList: collectionList,\n                collectionIndex: journeyNodeObject.collectionIndex,\n                language: node.language,\n                type: \"journey\",\n                words: collectionList[journeyNodeObject.collectionIndex].words\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 457,\n                columnNumber: 22\n              }, this));\n            }\n          }, {\n            text: \"Remove node\",\n            handler: e => {\n              removeNode(e, journeyNodeObject.collectionIndex, node.arrayIndex);\n            }\n          }];\n          openContextMenu(e, /*#__PURE__*/_jsxDEV(ContextMenu, {\n            x: e.clientX,\n            y: e.clientY,\n            items: contextMenuItems\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 468,\n            columnNumber: 25\n          }, this));\n        }; // Dimensions of bottom-right corner\n\n\n        const squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\n        const circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")), 2);\n        const cornerWidth = (squareArea - circleArea) / 4 / 2; // Extract corners, divide by four, width and height are equal length (/2)\n        // Determine corner of circle's box\n\n        const southEastCorner = {\n          xStart: vertexX,\n          xEnd: vertexX + cornerWidth,\n          yStart: vertexY,\n          yEnd: vertexY + cornerWidth\n        };\n        let hoveringOverText = false;\n        const nodeDragHandler = d3.drag().on(\"start\", e => {\n          const vertexX = parseFloat(vertex.attr(\"cx\")),\n                vertexY = parseFloat(vertex.attr(\"cy\"));\n          const mouseX = e.x,\n                mouseY = e.y;\n          startX = vertexX;\n          startY = vertexY;\n          startXOffset = mouseX - vertexX;\n          startYOffset = mouseY - vertexY; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd && !hoveringOverText) {\n            resizing = true;\n            startX = mouseX;\n            startY = mouseY;\n            startRadius = parseFloat(vertex.attr(\"r\"));\n          }\n        }).on(\"drag\", e => {\n          const mouseX = e.x,\n                mouseY = e.y;\n\n          if (resizing) {\n            if (mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY) {\n              // Resize the vertex\n              const deltaX = mouseX - startX;\n              newVertexRadius = startRadius + deltaX / 10;\n              if (newVertexRadius < 10) newVertexRadius = 10; // Floor of 10px to prevent it shrinking into nothingness\n\n              vertex.attr(\"r\", newVertexRadius + \"px\"); // Only visually, not updating state itself\n              // Resize the vertex's text\n\n              const paddingOffset = 10;\n              newLabelSize = (newVertexRadius * 2 - paddingOffset) / innerTextWidth * 100 + \"%\";\n              text.style(\"font-size\", newLabelSize); // Move arrowheads as it is resized\n\n              if (markerSelectString) {\n                const selectString = markerSelectString.slice(0, markerSelectString.length - 2); // Trim \", \" at the end of string\n\n                d3.selectAll(selectString).attr(\"refX\", newVertexRadius / 2 + 5);\n              }\n            }\n          } else {\n            // Move the vertex\n            vertexX = mouseX - startXOffset;\n            vertexY = mouseY - startYOffset;\n            vertex.attr(\"cx\", vertexX).attr(\"cy\", vertexY); // Only visually\n\n            text.attr(\"x\", vertexX).attr(\"y\", vertexY); // Only visually\n            // Move the edges\n\n            const dataEnd = journeyNodeObject.collectionIndex + \"|\" + journeyNodeObject.node.arrayIndex;\n            const attachedEdges = d3.selectAll(\"line[data-start=\\\"\" + dataEnd + \"\\\"]\"); // Find all edges that start on this node\n\n            const attachedEdges2 = d3.selectAll(\"line[data-end=\\\"\" + dataEnd + \"\\\"]\"); // Find all edges that end on this node\n\n            if (attachedEdges) {\n              attachedEdges.attr(\"x1\", vertexX + startEdgeXOffset).attr(\"y1\", vertexY + startEdgeYOffset);\n            }\n\n            if (attachedEdges2) {\n              attachedEdges2.attr(\"x2\", vertexX + startEdgeXOffset).attr(\"y2\", vertexY + startEdgeYOffset);\n            }\n          }\n        }).on(\"end\", () => {\n          resizing = false;\n          node.vertex.x = vertexX;\n          node.vertex.y = vertexY;\n          node.vertex.radius = newVertexRadius || node.vertex.radius;\n          node.vertex.fontSize = newLabelSize || node.vertex.fontSize;\n          editNode(null, journeyNodeObject.collectionIndex, node);\n        }); // Assign handlers\n\n        text.on(\"contextmenu\", nodeContextMenuHandler);\n        text.call(nodeDragHandler);\n        text.on(\"mousemove\", () => {\n          text.style(\"cursor\", \"grab\");\n          hoveringOverText = true;\n        });\n        vertex.on(\"mousemove\", e => {\n          hoveringOverText = false;\n          const mouseX = e.layerX,\n                mouseY = e.layerY; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n            vertex.style(\"cursor\", \"se-resize\");\n          } else vertex.style(\"cursor\", \"grab\");\n        }).on(\"contextmenu\", nodeContextMenuHandler).call(nodeDragHandler);\n      }\n    } // Graticules (lines on the map)\n\n\n    const g = svg.append(\"g\");\n    const graticules = g.classed(\"graticules\", true).append(\"path\").attr(\"fill\", \"none\").attr(\"stroke\", \"rgba(0,0,0,.2)\").attr(\"d\", path(d3.geoGraticule()()));\n    /*\r\n    svg.call(d3.zoom().on(\"zoom\", function () {\r\n    \tz = d3.event.transform.k;\r\n    \tdraw(); // TODO: Contain above render code into draw() function\r\n    }));\r\n     */\n    // Clean-up function (kills all SVG elements upon unmounting)\n\n    return function cleanup() {\n      svg.selectAll(\"g\").remove();\n    };\n  });\n\n  function getLanguageProp(node) {\n    for (const l in languageProperties) {\n      const languageProp = languageProperties[l];\n      if (languageProp.language === node.language) return languageProp;\n    }\n\n    return {\n      \"language\": node.language,\n      \"x\": 0,\n      \"y\": 0,\n      \"width\": 0,\n      \"height\": 0,\n      \"radius\": 25\n    };\n  }\n  /**\r\n   * Finds all nodes in all collections of specified type where the node's language is within the feature's language array\r\n   * @param {*} d The dataset feature (country/region) currently being rendered\r\n   * @param {string} type The type of collection to search for (\"journey\" or \"cognate\")\r\n   */\n\n\n  function findNodes(d, type) {\n    // Search collections\n    if (type === \"cognate\") {\n      for (let c = 0; c < collections.length; ++c) {\n        const collection = collections[c];\n\n        if (collection.type === \"cognate\") {\n          for (let n = 0; n < collection.words.length; ++n) {\n            const childNode = collection.words[n];\n\n            if (d.properties.languages.includes(childNode.language)) {\n              return {\n                node: childNode,\n                collectionIndex: c,\n                arrayIndex: n\n              }; // TODO: Currently only returns first cognate\n            }\n          }\n        }\n      }\n    } else if (type === \"journey\") {\n      const journeyNodeObjects = [];\n\n      for (let c = 0; c < collections.length; ++c) // Search for all nodes in all journey collections\n      {\n        const collection = collections[c];\n\n        if (collection.type === \"journey\") {\n          for (let n = 0; n < collection.words.length; ++n) {\n            const childNode = collection.words[n];\n            journeyNodeObjects.push({\n              node: childNode,\n              collectionIndex: c\n            });\n          }\n        }\n      }\n\n      return journeyNodeObjects;\n    }\n  }\n  /**\r\n   * Determines country SVG fill colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n   * @param d Data attached to DOM element via D3 (i.e. the country).\r\n   * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n   */\n\n\n  function determineFillColour(d) {\n    const nodeObject = findNodes(d, \"cognate\"); // Find node in collections\n\n    if (nodeObject) return nodeObject.node.fillColour; // Country has associated collection node? Return the colour\n    else return \"white\"; // Otherwise, return white by default for all countries with no associated data\n  }\n  /**\r\n   * Determines country SVG stroke colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n   * @param d Data attached to DOM element via D3 (i.e. the country).\r\n   * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n   */\n\n\n  function determineStrokeColour(d) {\n    const nodeObject = findNodes(d, \"cognate\"); // Find node in collections\n\n    if (nodeObject) return nodeObject.node.strokeColour; // Country has associated collection node? Return the colour\n    else return \"black\"; // Otherwise, return black by default for all countries with no associated data\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      /*ref={ref}*/\n      id: \"map-svg\",\n      style: {\n        height: \"100%\",\n        width: \"100%\",\n        margin: 0\n      },\n      children: /*#__PURE__*/_jsxDEV(\"rect\", {\n        width: \"100%\",\n        height: \"100%\",\n        fill: \"#3d73ab\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 705,\n        columnNumber: 5\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 696,\n      columnNumber: 4\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 695,\n    columnNumber: 3\n  }, this);\n}\n\n_s(Map, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n_c = Map;\n\nvar _c;\n\n$RefreshReg$(_c, \"Map\");","map":{"version":3,"sources":["D:/xampp/htdocs/COMP3000_LEMA/client/src/components/Map.jsx"],"names":["React","useEffect","d3","AddEditNodeModal","ContextMenu","countriesData","languageProperties","Map","props","DEBUG_MODE","console","debug","openContextMenu","bind","addNode","editNode","removeNode","openModal","createToast","collections","svg","selectAll","countries","features","width","_groups","clientWidth","height","clientHeight","projection","geoConicConformal","center","scale","translate","path","geoPath","on","e","log","svgChildren","svgXInit","svgYInit","svgXOffset","svgYOffset","call","drag","attr","coordGroup","append","classed","countryPaths","data","enter","d","determineFillColour","determineStrokeColour","properties","name_long","x","offsetX","y","offsetY","remove","text","preventDefault","nodeObject","findNodes","contextMenuItems","handler","collectionList","filter","collection","i","type","collectionIndex","node","language","arrayIndex","length","word","parents","fillColour","strokeColour","label","customText","fontColour","fontSize","languages","unshift","vertex","radius","edgeStart","edgeEnd","edgeStrokeColour","edgeStrokeWidth","edgeArrowheadEnabled","edgeArrowheadStrokeColour","edgeArrowheadFillColour","clientX","clientY","element","select","edgesGroup","verticesLabelsGroup","each","f","cognateNodeObject","languageProp","getLanguageProp","boundingBox","getBBox","labelText","style","startXOffset","startYOffset","resizing","startX","startY","startSize","newSize","labelX","parseFloat","labelY","mouseX","layerX","mouseY","layerY","southEastCorner","xStart","xEnd","yStart","yEnd","deltaX","journeyNodeObjects","startEdgeXOffset","startEdgeYOffset","endEdgeXOffset","endEdgeYOffset","journeyNodeObject","vertexText","vertexX","vertexY","vertexG","preparedText","innerTextWidth","markerSelectString","parentNode","parentRef","nodeRef","edge","startRadius","newVertexRadius","newLabelSize","nodeContextMenuHandler","words","squareArea","circleArea","Math","PI","pow","cornerWidth","hoveringOverText","nodeDragHandler","paddingOffset","selectString","slice","dataEnd","attachedEdges","attachedEdges2","g","graticules","geoGraticule","cleanup","l","c","n","childNode","includes","push","margin"],"mappings":"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","sourcesContent":["import React, {useEffect} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {AddEditNodeModal} from \"./modals/AddEditNodeModal\";\r\nimport {ContextMenu} from \"./controls/ContextMenu\";\r\nimport countriesData from \"../data/countries/countries.json\";\r\nimport languageProperties from \"../data/languageProperties.json\";\r\n\r\nexport function Map(props)\r\n{\r\n\t// DEBUG MODE\r\n\tconst DEBUG_MODE = false;\r\n\r\n\tif(DEBUG_MODE)\r\n\t\tconsole.debug(\"[== MAP RENDER ==]\");\r\n\r\n\t// Prop functions\r\n\tconst openContextMenu = props.openContextMenu.bind(this);\r\n\tconst addNode = props.addNode.bind(this);\r\n\tconst editNode = props.editNode.bind(this);\r\n\tconst removeNode = props.removeNode.bind(this);\r\n\tconst openModal = props.openModal.bind(this);\r\n\tconst createToast = props.createToast.bind(this);\r\n\r\n\t// Props\r\n\tconst collections = props.collections;\r\n\r\n\t// Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\r\n\tuseEffect(() => {\r\n\t\tconst svg = d3.selectAll(\".map-container\").selectAll(\"svg\");\r\n\t\tconst countries = countriesData.features;\r\n\r\n\t\t// Create path (passed as svg attribute later to draw the countries)\r\n\t\t// TODO: Have it auto-scale as window is dragged/re-sized\r\n\t\tconst width = svg._groups[0][0].clientWidth;\r\n\t\tconst height = svg._groups[0][0].clientHeight;\r\n\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t.center([8, 52.823]) // Middle of Europe(ish)\r\n\t\t\t.scale(1650)\r\n\t\t\t.translate([width/2, height/2]);\r\n\t\tconst path = d3.geoPath().projection(projection);\r\n\r\n\t\tsvg.on(\"drag\", (e) => {\r\n\t\t\tconsole.log(e);\r\n\t\t});\r\n\t\tlet svgChildren = null, svgXInit = 0, svgYInit = 0, svgXOffset = 0, svgYOffset = 0;\r\n\t\tsvg.call(d3.drag()\r\n\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\tsvgChildren = d3.selectAll(\"svg#map-svg g\");\r\n\t\t\t\tconsole.log(e);\r\n\t\t\t})\r\n\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t// TODO: Determine drag direction\r\n\t\t\t\tconsole.log(svgChildren);\r\n\t\t\t\tsvgXOffset -= 10;\r\n\t\t\t\tsvgChildren.attr(\"style\", `transform: translate(${svgXOffset}px, ${svgYOffset}px)`);\r\n\t\t\t}));\r\n\r\n\t\tlet coordGroup;\r\n\t\tif(DEBUG_MODE)\r\n\t\t{\r\n\t\t\tcoordGroup = svg.append(\"g\")\r\n\t\t\t\t.classed(\"coords\", true)\r\n\t\t\t\t.attr('transform', 'translate(50,150)')\r\n\t\t}\r\n\r\n\r\n\t\t// Draw countries, bind data and handlers\r\n\t\tconst countryPaths = svg.append(\"g\")\r\n\t\t\t.selectAll(\"path\") // svg->g->path\r\n\t\t\t.data(countries)         // svg->g->path\r\n\t\t\t.enter()                 // svg->g->path (create new nodes per data)\r\n\t\t\t.append(\"path\")          // svg->g->path (create new nodes per data)\r\n\t\t\t.attr(\"fill\", (d) => determineFillColour(d))\r\n\t\t\t.attr(\"stroke\", (d) => determineStrokeColour(d))\r\n\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t.attr(\"d\", path)\r\n\t\t\t.on(\"click\", function(e, d){\r\n\t\t\t\t// TODO: Possibly same functions as context menu (see about calling this.onContextMenu() to keep things nice and DRY)\r\n\t\t\t\tcreateToast(e, d.properties.name_long, 2000);\r\n\t\t\t})\r\n\t\t\t.on(\"mousemove\", function(e, d)\r\n\t\t\t{\r\n\t\t\t\tif(DEBUG_MODE)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst x = e.offsetX - 612, y = e.offsetY - 528;\r\n\t\t\t\t\tcoordGroup.selectAll(\"text\").remove();\r\n\t\t\t\t\tcoordGroup.append(\"text\")\r\n\t\t\t\t\t\t.text(`(${x},${y})`)\r\n\t\t\t\t\t\t.attr(\"fill\", \"white\");\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.on(\"contextmenu\", function(e, d){\r\n\t\t\t\te.preventDefault(); // Prevent browser context menu from opening\r\n\t\t\t\tconst nodeObject = findNodes(d, \"cognate\");\r\n\t\t\t\tlet contextMenuItems = [];\r\n\r\n\t\t\t\t// If clicked-on country has attached cognate\r\n\t\t\t\tif(nodeObject)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Edit node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={editNode} node={nodeObject.node} collectionList={collectionList}\r\n\t\t\t\t\t\t\t\t                               collectionIndex={nodeObject.collectionIndex}\r\n\t\t\t\t\t\t\t\t                               type={\"cognate\"} language={nodeObject.node.language} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Remove node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tremoveNode(e, nodeObject.collectionIndex, nodeObject.arrayIndex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: Context menu for adding to new collection, adding to existing collection\r\n\t\t\t\t\tcontextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add country to collection (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\tif(collectionList.length <= 0)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tcreateToast(e, \"You must first create a cognate collection for the node to be added to.\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst node = {word: \"\", language: \"\", parents: []};\r\n\t\t\t\t\t\t\t\t\tnode.fillColour = \"#FF0000\"; node.strokeColour = \"#000000\";\r\n\t\t\t\t\t\t\t\t\tnode.label = {type: \"word\", customText: \"\", fontColour: \"#000000\", fontSize: null, x: null, y: null};\r\n\t\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal isNewWord={true} onNodeSubmit={addNode} node={node} type={\"cognate\"} collectionList={collectionList} collectionIndex={collectionList[0].collectionIndex} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Common to both\r\n\t\t\t\tcontextMenuItems.unshift(\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttext: \"Add new node (journey)\", handler: (e) => {\r\n\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\tif(collectionList.length <= 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcreateToast(e, \"You must first create a journey collection for the node to be added to.\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Open the AddEditNodeModal with initial node data\r\n\t\t\t\t\t\t\t\tconst node = {word: \"\", language: d.properties.languages[0], parents: []};\r\n\t\t\t\t\t\t\t\tnode.vertex = {type: \"word\", customText: \"\", fontColour: \"#000000\", strokeColour: \"#000000\", fillColour: \"#FFFFFF\", radius: null, fontSize: null, x: null, y: null, edgeStart: \"centre\", edgeEnd: \"centre\", edgeStrokeColour: \"#000000\", edgeStrokeWidth: \"2px\", edgeArrowheadEnabled: true, edgeArrowheadStrokeColour: \"#000000\", edgeArrowheadFillColour: \"#000000\"};\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal isNewWord={true} node={node} type={\"journey\"} onNodeSubmit={addNode} collectionList={collectionList} collectionIndex={collectionList[0].collectionIndex} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t})\r\n\t\t\t.on(\"mouseover\", function(e, d){\r\n\t\t\t\tconst element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"white\") // White can't become transparent\r\n\t\t\t\t\telement.attr(\"fill\", \"rgb(230,230,230)\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"0.65\");\r\n\t\t\t})\r\n\t\t\t.on(\"mouseout\", function(e, d){\r\n\t\t\t\tconst element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"rgb(230,230,230)\") // Reset white\r\n\t\t\t\t\telement.attr(\"fill\", \"white\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"1\");\r\n\t\t\t});\r\n\r\n\t\t// Cognate labels, journey vertices\r\n\t\tconst edgesGroup = svg.append(\"g\").classed(\"edges\", true); // SVG group for edges\r\n\t\tedgesGroup.on(\"contextmenu\", (e) => e.preventDefault());\r\n\t\tconst verticesLabelsGroup = svg.append(\"g\").classed(\"vertices-labels\", true); // SVG group for vertices AND cognate labels\r\n\t\tcountryPaths.each(function(f, i) {\r\n\t\t\tconst cognateNodeObject = findNodes(f, \"cognate\");  // The first node in any cognate collection that belongs to this country/region\r\n\t\t\tif(cognateNodeObject)\r\n\t\t\t{\r\n\t\t\t\t/* Cognate visualisations */\r\n\t\t\t\tconst node = cognateNodeObject.node;\r\n\t\t\t\tconst languageProp = getLanguageProp(node);\r\n\t\t\t\tconst boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\r\n\t\t\t\tlet fontSize = node.label.fontSize;                 // Font size of the label\r\n\t\t\t\tlet labelText = node.word;                          // Word by default\r\n\t\t\t\tif(node.label.type === \"Country/region\") labelText = f.properties.name_long;\r\n\t\t\t\telse if(node.label.type === \"Custom text\") labelText = node.label.customText;\r\n\t\t\t\telse if(node.label.type === \"Language\") labelText = node.language;\r\n\r\n\t\t\t\t// Initial scale factor depending on size of country (to stop oversized text from escaping country)\r\n\t\t\t\tif(labelText.length !== 0 && !node.label.fontSize) // Only scale if font size hasn't been set by user\r\n\t\t\t\t{\r\n\t\t\t\t\tif(boundingBox.width < (labelText.length * 16))\r\n\t\t\t\t\t\tfontSize = boundingBox.width/8 + \"px\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Initial co-ordinates\r\n\t\t\t\tlet x = (node.label.x === null) ? (languageProp.x + 612) : node.label.x;\r\n\t\t\t\tlet y = (node.label.y === null) ? (languageProp.y + 528) : node.label.y;\r\n\t\t\t\tconst label = verticesLabelsGroup.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", x).attr(\"y\", y)\r\n\t\t\t\t\t.attr(\"fill\", node.label.fontColour)\r\n\t\t\t\t\t.attr(\"font-family\", \"'Segoe UI', sans-serif\")\r\n\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t.text(labelText);\r\n\r\n\t\t\t\t// Dragging/resizing handlers\r\n\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startSize, newSize;\r\n\t\t\t\tlabel\r\n\t\t\t\t\t.on(\"mousemove\", (e) => {\r\n\t\t\t\t\t\tconst labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\tconst mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"grab\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.call(d3.drag()\r\n\t\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\t\tconst labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tstartXOffset = mouseX - labelX;\r\n\t\t\t\t\t\t\tstartYOffset = mouseY - labelY;\r\n\r\n\t\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\t\tstartSize = parseFloat(label.style(\"font-size\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Resize the label\r\n\t\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\t\tnewSize = startSize + (deltaX / 10);\r\n\t\t\t\t\t\t\t\t\tif(newSize < 5) newSize = 5; // Floor of 5px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\t\tlabel.style(\"font-size\", newSize + \"px\"); // Only visually, not updating state itself\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Move the label\r\n\t\t\t\t\t\t\t\tx = mouseX - startXOffset;\r\n\t\t\t\t\t\t\t\ty = mouseY - startYOffset;\r\n\t\t\t\t\t\t\t\tnewSize = node.label.fontSize;\r\n\t\t\t\t\t\t\t\tlabel.attr(\"x\", x).attr(\"y\", y); // Only visually\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\t\tnode.label.x = x; node.label.y = y; node.label.fontSize = newSize;\r\n\t\t\t\t\t\t\teditNode(null, cognateNodeObject.collectionIndex, node);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Journeys\r\n\t\tconst journeyNodeObjects = findNodes(null, \"journey\");\r\n\t\tif(journeyNodeObjects)\r\n\t\t{\r\n\t\t\t/* Journey visualisations */\r\n\r\n\t\t\t// Loop through all journey nodes inside this country/region\r\n\t\t\tlet startEdgeXOffset = 0, startEdgeYOffset = 0, endEdgeXOffset = 0, endEdgeYOffset = 0; // Centre by default\r\n\t\t\tfor(let i = 0; i < journeyNodeObjects.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tconst journeyNodeObject = journeyNodeObjects[i];\r\n\t\t\t\tconst node = journeyNodeObject.node;\r\n\t\t\t\tconst languageProp = getLanguageProp(node);\r\n\t\t\t\tlet radius = node.vertex.radius || languageProp.radius || 50; // Inherit radius (determined later if null)\r\n\t\t\t\tconst fontSize = node.vertex.fontSize;\r\n\t\t\t\tlet vertexText = node.word;  // Word by default\r\n\t\t\t\tif(node.vertex.type === \"Custom text\") vertexText = node.vertex.customText;\r\n\t\t\t\telse if(node.vertex.type === \"Language\") vertexText = node.language;\r\n\r\n\t\t\t\t/* Build node elements - VERTEX */\r\n\r\n\t\t\t\t// Initial co-ordinates\r\n\t\t\t\tlet vertexX = (node.vertex.x === null) ? (languageProp.x + 612) : node.vertex.x;\r\n\t\t\t\tlet vertexY = (node.vertex.y === null) ? (languageProp.y + 528) : node.vertex.y;\r\n\r\n\t\t\t\t// Set initial vertex position\r\n\t\t\t\tif(!node.vertex.x || !node.vertex.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY;\r\n\t\t\t\t\treturn editNode(null, journeyNodeObject.collectionIndex, node); // Performance TODO: Make this a bulk update instead to prevent re-rendering loop\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Prepare text element. This is required to calculate circle radius based on text element's width\r\n\t\t\t\tconst vertexG = verticesLabelsGroup.append(\"g\"); // Group required to have circle and text together\r\n\t\t\t\tconst preparedText = vertexG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fontColour)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t.attr(\"font-family\", \"'Segoe UI', sans-serif\")\r\n\t\t\t\t\t.style(\"font-size\", \"16px\")\r\n\t\t\t\t\t.text(vertexText);\r\n\r\n\t\t\t\t// Determine initial radius of circle\r\n\t\t\t\tconst innerTextWidth = preparedText.node().getBBox().width;\r\n\t\t\t\tif(vertexText.length !== 0 && !node.vertex.radius) // Only scale if font size hasn't been set by user\r\n\t\t\t\t{\r\n\t\t\t\t\tif(radius < innerTextWidth) radius = innerTextWidth/2 + 5; // Convert text \"diameter\" to radius, add padding\r\n\t\t\t\t}\r\n\t\t\t\tpreparedText.remove(); // Remove prepared text element. It will not show if appended before the circle\r\n\r\n\t\t\t\t/* Build node elements - EDGE */\r\n\r\n\t\t\t\t// Place edge between this node and its parents\r\n\t\t\t\tlet markerSelectString = \"\"; // String to select markers so that they can move whilst being resized\r\n\t\t\t\tif(node.parents)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Create edge for each parent, originating from this node\r\n\t\t\t\t\tfor(let i = 0; i < node.parents.length; ++i)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst parentNode = node.parents[i];\r\n\r\n\t\t\t\t\t\t// Fingerprint references for marker IDs and data-start/data-end attributes\r\n\t\t\t\t\t\tconst parentRef = journeyNodeObject.collectionIndex + \"|\" + parentNode.arrayIndex;\r\n\t\t\t\t\t\tconst nodeRef = journeyNodeObject.collectionIndex + \"|\" + node.arrayIndex;\r\n\r\n\t\t\t\t\t\t// Compute arrowheads\r\n\t\t\t\t\t\tif(node.vertex.edgeArrowheadEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tedgesGroup.append(\"defs\")\r\n\t\t\t\t\t\t\t\t.append(\"marker\")\r\n\t\t\t\t\t\t\t\t.attr(\"id\", \"arrow\" + parentRef + nodeRef)\r\n\t\t\t\t\t\t\t\t.attr(\"markerWidth\", 5).attr(\"markerHeight\", 4)\r\n\t\t\t\t\t\t\t\t.attr(\"refX\", radius/2 + 5).attr(\"refY\", 2)\r\n\t\t\t\t\t\t\t\t.attr(\"orient\", \"auto\")\r\n\t\t\t\t\t\t\t\t.append(\"polygon\")\r\n\t\t\t\t\t\t\t\t.attr(\"points\", \"0 0, 5 2, 0 4\")\r\n\t\t\t\t\t\t\t\t.attr(\"fill\", node.vertex.edgeArrowheadFillColour)\r\n\t\t\t\t\t\t\t\t.attr(\"stroke\", node.vertex.edgeArrowheadStrokeColour)\r\n\t\t\t\t\t\t\t\t.attr(\"id\", nodeRef);\r\n\t\t\t\t\t\t\tmarkerSelectString += \"marker[id=\\\"arrow\"+parentRef+nodeRef+\"\\\"], \";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Determine edge start position\r\n\t\t\t\t\t\tif(node.vertex.edgeStart === \"top\") startEdgeYOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"right\") startEdgeXOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"bottom\") startEdgeYOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"left\") startEdgeXOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"centre\") {\r\n\t\t\t\t\t\t\tstartEdgeXOffset = 0; startEdgeYOffset = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Determine edge end position\r\n\t\t\t\t\t\tif(node.vertex.edgeEnd === \"top\") endEdgeYOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"right\") endEdgeXOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"bottom\") endEdgeYOffset = radius;\r\n\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"left\") endEdgeXOffset = -(radius);\r\n\t\t\t\t\t\telse if(node.vertex.edgeStart === \"centre\") {\r\n\t\t\t\t\t\t\tendEdgeXOffset = 0; endEdgeYOffset = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Place edge\r\n\t\t\t\t\t\tconst edge = edgesGroup.append(\"line\")\r\n\t\t\t\t\t\t\t.attr(\"x1\", parentNode.vertex.x + startEdgeXOffset)\r\n\t\t\t\t\t\t\t.attr(\"y1\", parentNode.vertex.y + startEdgeYOffset)\r\n\t\t\t\t\t\t\t.attr(\"x2\", node.vertex.x + endEdgeXOffset)\r\n\t\t\t\t\t\t\t.attr(\"y2\", node.vertex.y + endEdgeYOffset)\r\n\t\t\t\t\t\t\t.attr(\"stroke\", node.vertex.edgeStrokeColour)\r\n\t\t\t\t\t\t\t.attr(\"stroke-width\", node.vertex.edgeStrokeWidth)\r\n\t\t\t\t\t\t\t.attr(\"data-start\", parentRef) // For finding attached edges later\r\n\t\t\t\t\t\t\t.attr(\"data-end\", nodeRef);\r\n\r\n\t\t\t\t\t\tif(node.vertex.edgeArrowheadEnabled)\r\n\t\t\t\t\t\t\tedge.attr(\"marker-end\", \"url(#arrow\"+parentRef+nodeRef+\")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Place node elements\r\n\t\t\t\tconst vertex = vertexG.append(\"circle\")\r\n\t\t\t\t\t.attr(\"cx\", vertexX).attr(\"cy\", vertexY)\r\n\t\t\t\t\t.attr(\"r\", radius + \"px\")\r\n\t\t\t\t\t.attr(\"stroke\", node.vertex.strokeColour)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fillColour);\r\n\t\t\t\tconst text = vertexG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t.attr(\"fill\", node.vertex.fontColour)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t.attr(\"font-family\", \"'Segoe UI', sans-serif\")\r\n\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t.text(vertexText);\r\n\r\n\t\t\t\t/* Dragging/resizing/clicking handlers */\r\n\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startRadius, newVertexRadius, newLabelSize;\r\n\t\t\t\tconst nodeContextMenuHandler = (e) => {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tconst contextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Edit node\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tconst collectionList = collections.filter((collection, i) => {\r\n\t\t\t\t\t\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tcollection.collectionIndex = i;\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={editNode} node={node} collectionList={collectionList}\r\n\t\t\t\t\t\t\t\t                               collectionIndex={journeyNodeObject.collectionIndex} language={node.language}\r\n\t\t\t\t\t\t\t\t                               type={\"journey\"} words={collectionList[journeyNodeObject.collectionIndex].words}  />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Remove node\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tremoveNode(e, journeyNodeObject.collectionIndex, node.arrayIndex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Dimensions of bottom-right corner\r\n\t\t\t\tconst squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\r\n\t\t\t\tconst circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")),2);\r\n\t\t\t\tconst cornerWidth = ((squareArea - circleArea) / 4) / 2; // Extract corners, divide by four, width and height are equal length (/2)\r\n\r\n\t\t\t\t// Determine corner of circle's box\r\n\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\txStart: vertexX,\r\n\t\t\t\t\txEnd: vertexX + cornerWidth,\r\n\t\t\t\t\tyStart: vertexY,\r\n\t\t\t\t\tyEnd: vertexY + cornerWidth\r\n\t\t\t\t}\r\n\t\t\t\tlet hoveringOverText = false;\r\n\t\t\t\tconst nodeDragHandler = d3.drag()\r\n\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\tconst vertexX = parseFloat(vertex.attr(\"cx\")), vertexY = parseFloat(vertex.attr(\"cy\"));\r\n\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\tstartX = vertexX;\r\n\t\t\t\t\t\tstartY = vertexY;\r\n\t\t\t\t\t\tstartXOffset = mouseX - vertexX;\r\n\t\t\t\t\t\tstartYOffset = mouseY - vertexY;\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd\r\n\t\t\t\t\t\t\t&& !hoveringOverText)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\tstartRadius = parseFloat(vertex.attr(\"r\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\tconst mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Resize the vertex\r\n\t\t\t\t\t\t\t\tconst deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\tnewVertexRadius = startRadius + (deltaX / 10);\r\n\t\t\t\t\t\t\t\tif(newVertexRadius < 10) newVertexRadius = 10; // Floor of 10px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\tvertex.attr(\"r\", newVertexRadius + \"px\"); // Only visually, not updating state itself\r\n\r\n\t\t\t\t\t\t\t\t// Resize the vertex's text\r\n\t\t\t\t\t\t\t\tconst paddingOffset = 10;\r\n\t\t\t\t\t\t\t\tnewLabelSize = ((((newVertexRadius*2) - paddingOffset) / innerTextWidth) * 100) + \"%\";\r\n\t\t\t\t\t\t\t\ttext.style(\"font-size\", newLabelSize);\r\n\r\n\t\t\t\t\t\t\t\t// Move arrowheads as it is resized\r\n\t\t\t\t\t\t\t\tif(markerSelectString)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tconst selectString = markerSelectString.slice(0, markerSelectString.length-2); // Trim \", \" at the end of string\r\n\t\t\t\t\t\t\t\t\td3.selectAll(selectString).attr(\"refX\", newVertexRadius/2+5);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Move the vertex\r\n\t\t\t\t\t\t\tvertexX = mouseX - startXOffset;\r\n\t\t\t\t\t\t\tvertexY = mouseY - startYOffset;\r\n\t\t\t\t\t\t\tvertex.attr(\"cx\", vertexX).attr(\"cy\", vertexY); // Only visually\r\n\t\t\t\t\t\t\ttext.attr(\"x\", vertexX).attr(\"y\", vertexY); // Only visually\r\n\r\n\t\t\t\t\t\t\t// Move the edges\r\n\t\t\t\t\t\t\tconst dataEnd = journeyNodeObject.collectionIndex + \"|\" + journeyNodeObject.node.arrayIndex;\r\n\t\t\t\t\t\t\tconst attachedEdges = d3.selectAll(\"line[data-start=\\\"\"+dataEnd+\"\\\"]\"); // Find all edges that start on this node\r\n\t\t\t\t\t\t\tconst attachedEdges2 = d3.selectAll(\"line[data-end=\\\"\"+dataEnd+\"\\\"]\");  // Find all edges that end on this node\r\n\t\t\t\t\t\t\tif(attachedEdges)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tattachedEdges.attr(\"x1\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t.attr(\"y1\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(attachedEdges2)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tattachedEdges2.attr(\"x2\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t.attr(\"y2\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY; node.vertex.radius = newVertexRadius || node.vertex.radius; node.vertex.fontSize = newLabelSize || node.vertex.fontSize;\r\n\t\t\t\t\t\teditNode(null, journeyNodeObject.collectionIndex, node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t// Assign handlers\r\n\t\t\t\ttext.on(\"contextmenu\", nodeContextMenuHandler);\r\n\t\t\t\ttext.call(nodeDragHandler);\r\n\t\t\t\ttext.on(\"mousemove\", () => {\r\n\t\t\t\t\ttext.style(\"cursor\", \"grab\");\r\n\t\t\t\t\thoveringOverText = true;\r\n\t\t\t\t});\r\n\t\t\t\tvertex.on(\"mousemove\", (e) => {\r\n\t\t\t\t\thoveringOverText = false;\r\n\t\t\t\t\tconst mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t// Check corner\r\n\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvertex.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvertex.style(\"cursor\", \"grab\");\r\n\t\t\t\t})\r\n\t\t\t\t.on(\"contextmenu\", nodeContextMenuHandler)\r\n\t\t\t\t.call(nodeDragHandler);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Graticules (lines on the map)\r\n\t\tconst g = svg.append(\"g\");\r\n\t\tconst graticules = g.classed(\"graticules\", true)\r\n\t\t\t.append(\"path\")\r\n\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\")\r\n\t\t\t.attr(\"d\", path(d3.geoGraticule()()));\r\n\r\n\t\t/*\r\n\t\tsvg.call(d3.zoom().on(\"zoom\", function () {\r\n\t\t\tz = d3.event.transform.k;\r\n\t\t\tdraw(); // TODO: Contain above render code into draw() function\r\n\t\t}));\r\n\t\t */\r\n\r\n\t\t// Clean-up function (kills all SVG elements upon unmounting)\r\n\t\treturn function cleanup()\r\n\t\t{\r\n\t\t\tsvg.selectAll(\"g\").remove();\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tfunction getLanguageProp(node)\r\n\t{\r\n\t\tfor(const l in languageProperties)\r\n\t\t{\r\n\t\t\tconst languageProp = languageProperties[l];\r\n\t\t\tif(languageProp.language === node.language)\r\n\t\t\t\treturn languageProp;\r\n\t\t}\r\n\t\treturn {\r\n\t\t\t\"language\": node.language,\r\n\t\t\t\"x\": 0,\r\n\t\t\t\"y\": 0,\r\n\t\t\t\"width\": 0,\r\n\t\t\t\"height\": 0,\r\n\t\t\t\"radius\": 25\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds all nodes in all collections of specified type where the node's language is within the feature's language array\r\n\t * @param {*} d The dataset feature (country/region) currently being rendered\r\n\t * @param {string} type The type of collection to search for (\"journey\" or \"cognate\")\r\n\t */\r\n\tfunction findNodes(d, type)\r\n\t{\r\n\t\t// Search collections\r\n\t\tif(type === \"cognate\")\r\n\t\t{\r\n\t\t\tfor(let c = 0; c < collections.length; ++c)\r\n\t\t\t{\r\n\t\t\t\tconst collection = collections[c];\r\n\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst childNode = collection.words[n];\r\n\r\n\t\t\t\t\t\tif(d.properties.languages.includes(childNode.language))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn {node: childNode, collectionIndex: c, arrayIndex: n}; // TODO: Currently only returns first cognate\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(type === \"journey\")\r\n\t\t{\r\n\t\t\tconst journeyNodeObjects = [];\r\n\t\t\tfor(let c = 0; c < collections.length; ++c) // Search for all nodes in all journey collections\r\n\t\t\t{\r\n\t\t\t\tconst collection = collections[c];\r\n\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst childNode = collection.words[n];\r\n\t\t\t\t\t\tjourneyNodeObjects.push({node: childNode, collectionIndex: c});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn journeyNodeObjects;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Determines country SVG fill colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n\t * @param d Data attached to DOM element via D3 (i.e. the country).\r\n\t * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n\t */\r\n\tfunction determineFillColour(d)\r\n\t{\r\n\t\tconst nodeObject = findNodes(d, \"cognate\"); // Find node in collections\r\n\t\tif(nodeObject) return nodeObject.node.fillColour;    // Country has associated collection node? Return the colour\r\n\t\telse return \"white\";                             // Otherwise, return white by default for all countries with no associated data\r\n\t}\r\n\t/**\r\n\t * Determines country SVG stroke colour according to countries' language(s) and the specified colour of that language's cognate node(s).\r\n\t * @param d Data attached to DOM element via D3 (i.e. the country).\r\n\t * @returns {string} The fill colour, as specified by user in Collection.jsx.\r\n\t */\r\n\tfunction determineStrokeColour(d)\r\n\t{\r\n\t\tconst nodeObject = findNodes(d, \"cognate\");       // Find node in collections\r\n\t\tif(nodeObject) return nodeObject.node.strokeColour;    // Country has associated collection node? Return the colour\r\n\t\telse return \"black\";                                   // Otherwise, return black by default for all countries with no associated data\r\n\t}\r\n\r\n\treturn (\r\n\t\t<div className={\"map-container\"}>\r\n\t\t\t<svg\r\n\t\t\t\t/*ref={ref}*/\r\n\t\t\t\tid={\"map-svg\"}\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\theight: \"100%\",\r\n\t\t\t\t\twidth: \"100%\",\r\n\t\t\t\t\tmargin: 0\r\n\t\t\t\t}}\r\n\t\t\t>\r\n\t\t\t\t<rect width={\"100%\"} height={\"100%\"} fill={\"#3d73ab\"}/>\r\n\t\t\t</svg>\r\n\t\t</div>\r\n\t);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}