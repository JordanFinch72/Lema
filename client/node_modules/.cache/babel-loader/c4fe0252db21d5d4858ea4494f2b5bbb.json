{"ast":null,"code":"var _jsxFileName = \"D:\\\\xampp\\\\htdocs\\\\COMP3000_LEMA\\\\Project\\\\lema\\\\src\\\\components\\\\Map.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { useD3 } from \"../hooks/useD3\";\nimport languageCountries from \"../supportedLanguages.json\";\nimport countries_data from \"../data/countries/countries.json\";\nimport { AddEditNodeModal } from \"./AddEditNodeModal\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function Map(props) {\n  _s();\n\n  // Prop functions\n  const openContextMenu = props.openContextMenu.bind(this);\n  const addNode = props.addNode.bind(this);\n  const editNode = props.editNode.bind(this);\n  const removeNode = props.removeNode.bind(this);\n  const openModal = props.openModal.bind(this);\n  const collections = props.collections;\n  let flattenedCollections = [];\n\n  for (let i = 0; i < collections.length; ++i) {\n    let flattenedTree = [];\n    flattenedTree = flattenTree(flattenedTree, collections[i].words[0], 0, \"\", i);\n    flattenedCollections.push({\n      type: collections[i].type,\n      words: flattenedTree\n    });\n  }\n\n  console.log(\"[== MAP RENDER ==]\");\n\n  let topojson = require(\"topojson\");\n\n  let countries_data = require(\"../data/countries/countries.json\"); // Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\n\n\n  useEffect(() => {\n    let svg = d3.selectAll(\".map-container\").selectAll(\"svg\");\n    let countries = countries_data.features; // Create path (passed as svg attribute later to draw the countries)\n    // TODO: Have it auto-scale as window is dragged\n\n    const width = svg._groups[0][0].clientWidth;\n    const height = svg._groups[0][0].clientHeight;\n    const projection = d3.geoConicConformal().center([8, 52.823]) // Middle of Europe(ish)\n    .scale(1360).translate([width / 2, height / 2]);\n    const path = d3.geoPath().projection(projection); // Draw countries, bind data and handlers\n\n    let countryPaths = svg.append(\"g\").selectAll(\"path\") // svg->g->path\n    .data(countries) // svg->g->path\n    .enter() // svg->g->path (create new nodes per data)\n    .append(\"path\") // svg->g->path (create new nodes per data)\n    .attr(\"fill\", d => determineFillColour(d)).on(\"click\", function (e, d) {// TODO: Possibly same functions as context menu (see about calling this.onContextMenu() to keep things nice and DRY)\n    }).on(\"contextmenu\", function (e, d) {\n      e.preventDefault(); // Prevent browser context menu from opening\n\n      const nodeObject = findNodes(d, \"cognate\");\n\n      if (nodeObject) {\n        const contextMenuItems = [{\n          text: \"Add new node (journey)\",\n          handler: e => {\n            // Add new journey node within the country/region they right-clicked on (there may be multiple nodes in one country/region for journeys)\n            let collectionList = collections.filter(collection => collection.type === \"journey\"); // Journeys only\n\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: addNode,\n              collectionList: collectionList,\n              node: nodeObject.node,\n              language: d.properties.languages\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 70,\n              columnNumber: 22\n            }, this));\n          }\n        }, {\n          text: \"Add sibling node (cognate)\",\n          handler: e => {\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: addNode,\n              collectionIndex: nodeObject.collectionIndex,\n              node: nodeObject.node,\n              language: d.properties.languages\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 75,\n              columnNumber: 22\n            }, this));\n          }\n        }, {\n          text: \"Edit node (cognate)\",\n          handler: e => {\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: editNode,\n              collectionIndex: nodeObject.collectionIndex,\n              wordIndex: nodeObject.wordIndex,\n              node: nodeObject.node,\n              language: nodeObject.node.language\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 80,\n              columnNumber: 22\n            }, this));\n          }\n        }, {\n          text: \"Remove node (cognate)\",\n          handler: e => {\n            removeNode(e, nodeObject.collectionIndex, nodeObject.wordIndex);\n          }\n        }];\n        openContextMenu(e, /*#__PURE__*/_jsxDEV(ContextMenu, {\n          x: e.clientX,\n          y: e.clientY,\n          items: contextMenuItems\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 90,\n          columnNumber: 25\n        }, this));\n      } else {\n        // TODO: Context menu for adding to new collection, adding to existing collection\n        const contextMenuItems = [{\n          text: \"Add new node (journey)\",\n          handler: e => {\n            let collectionList = collections.filter(collection => collection.type === \"journey\"); // Journeys only\n\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: addNode,\n              collectionList: collectionList,\n              language: d.properties.languages\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 99,\n              columnNumber: 22\n            }, this));\n          }\n        }, {\n          text: \"Add to collection (cognate)\",\n          handler: e => {\n            let collectionList = collections.filter(collection => collection.type === \"cognate\"); // Cognates only\n\n            openModal(e, /*#__PURE__*/_jsxDEV(AddEditNodeModal, {\n              onNodeSubmit: addNode,\n              collectionList: collectionList,\n              language: d.properties.languages\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 105,\n              columnNumber: 22\n            }, this));\n          }\n        }];\n        openContextMenu(e, /*#__PURE__*/_jsxDEV(ContextMenu, {\n          x: e.clientX,\n          y: e.clientY,\n          items: contextMenuItems\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 109,\n          columnNumber: 25\n        }, this));\n      }\n    }).on(\"mouseover\", function (e, d) {\n      let element = d3.select(this);\n      if (element.attr(\"fill\") === \"white\") // White can't become transparent\n        element.attr(\"fill\", \"rgb(230,230,230)\");else element.attr(\"fill-opacity\", \"0.65\");\n    }).on(\"mouseout\", function (e, d) {\n      let element = d3.select(this);\n      if (element.attr(\"fill\") === \"rgb(230,230,230)\") // Reset white\n        element.attr(\"fill\", \"white\");else element.attr(\"fill-opacity\", \"1\");\n    }).attr(\"stroke\", \"black\").attr(\"stroke-linejoin\", \"round\").attr(\"d\", path); // Cognate labels, journey vertices\n\n    const vertexEdgesG = svg.append(\"g\").classed(\"vertex-edges\", true); // SVG group for edges\n\n    const verticesLabelsG = svg.append(\"g\").classed(\"vertices-labels\", true); // SVG group for vertices AND cognate labels\n\n    countryPaths.each(function (f, i) {\n      // Only place labels of countries with associated cognate data\n      // TODO: Make this a setting\n      let cognateNodeObject = findNodes(f, \"cognate\");\n      let journeyNodeObjects = findNodes(f, \"journey\"); // All nodes across all journey collections belonging to this country/region\n\n      if (cognateNodeObject) {\n        /* Cognate visualisations */\n        let node = cognateNodeObject.node;\n        let boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\n\n        let fontSize = node.label.fontSize; // Font size of the label\n\n        let labelText = node.language; // Language by default\n\n        if (node.label.type === \"country\") labelText = f.properties.name_long;else if (node.label.type === \"customText\") labelText = node.label.customText;else if (node.label.type === \"word\") labelText = node.word; // TODO: Initial scale factor depending on size of country (to stop oversized text from escaping country)\n\n        if (labelText.length !== 0 && !node.label.fontSize) // Only scale if font size hasn't been set by user\n          {\n            if (boundingBox.width < labelText.length * 16) fontSize = boundingBox.width / 8 + \"px\";\n          } // Append labels to paths, with co-ordinates according to feature's position on map\n\n\n        let x = node.label.x === null ? boundingBox.x + boundingBox.width / 4 : node.label.x;\n        let y = node.label.y === null ? boundingBox.y + boundingBox.height / 2 : node.label.y;\n        let label = verticesLabelsG.append(\"text\").attr(\"x\", x).attr(\"y\", y).attr(\"fill\", node.label.fontColour).style(\"font-size\", fontSize).text(labelText); // Dragging/resizing handlers\n\n        let startXOffset,\n            startYOffset,\n            resizing = false,\n            startX,\n            startY,\n            startSize,\n            newSize;\n        label.on(\"mousemove\", e => {\n          let labelX = parseFloat(label.attr(\"x\")),\n              labelY = parseFloat(label.attr(\"y\"));\n          let mouseX = e.layerX,\n              mouseY = e.layerY; // Determine corner of text's box\n\n          const southEastCorner = {\n            xStart: labelX + label.node().getBBox().width - 5,\n            xEnd: labelX + label.node().getBBox().width + 15,\n            yStart: labelY,\n            yEnd: labelY + 10\n          }; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n            label.style(\"cursor\", \"se-resize\");\n          } else label.style(\"cursor\", \"grab\");\n        }).call(d3.drag().on(\"start\", e => {\n          let labelX = parseFloat(label.attr(\"x\")),\n              labelY = parseFloat(label.attr(\"y\"));\n          let mouseX = e.x,\n              mouseY = e.y;\n          startXOffset = mouseX - labelX;\n          startYOffset = mouseY - labelY; // Determine corner of text's box\n\n          const southEastCorner = {\n            xStart: labelX + label.node().getBBox().width - 5,\n            xEnd: labelX + label.node().getBBox().width + 15,\n            yStart: labelY,\n            yEnd: labelY + 10\n          }; // Check corner\n\n          if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n            resizing = true;\n            startX = mouseX;\n            startY = mouseY;\n            startSize = parseFloat(label.style(\"font-size\"));\n          }\n        }).on(\"drag\", e => {\n          let mouseX = e.x,\n              mouseY = e.y;\n\n          if (resizing) {\n            // Resize the label\n            if (mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY) {\n              let deltaX = mouseX - startX;\n              newSize = startSize + deltaX / 10;\n              if (newSize < 5) newSize = 5; // Floor of 5px to prevent it shrinking into nothingness\n\n              label.style(\"font-size\", newSize + \"px\"); // Only visually, not updating state itself\n            }\n          } else {\n            // Move the label\n            x = mouseX - startXOffset;\n            y = mouseY - startYOffset;\n            label.attr(\"x\", x).attr(\"y\", y); // Only visually\n          }\n        }).on(\"end\", () => {\n          resizing = false;\n          node.x = x;\n          node.y = y;\n          node.newSize = newSize;\n          editNode(null, cognateNodeObject.collectionIndex, cognateNodeObject.node.indexChain, node); //moveLabel(cognateNodeObject.collectionIndex, cognateNodeObject.node.indexChain, x, y, newSize); // Set final properties\n        }));\n      }\n\n      if (journeyNodeObjects) {\n        /* Journey visualisations */\n        // Loop through all journey nodes inside this country/region\n        let xOffset = 0,\n            yOffset = 0,\n            prevDiameter = 0;\n        let startEdgeXOffset = 0,\n            startEdgeYOffset = 0,\n            endEdgeXOffset = 0,\n            endEdgeYOffset = 0; // Centre by default\n\n        for (let i = 0; i < journeyNodeObjects.length; ++i) {\n          let journeyNodeObject = journeyNodeObjects[i];\n          let node = journeyNodeObject.node;\n          let nextNodeObject = findNextNode(journeyNodeObject.collectionIndex, journeyNodeObject.wordIndex);\n          let nextNode = nextNodeObject ? nextNodeObject.node : null;\n          let boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\n\n          let radius = node.vertex.radius || 50; // Inherit radius (determined later if null)\n\n          let fontSize = node.vertex.fontSize;\n          let vertexText = node.language; // Language by default\n\n          if (node.vertex.type === \"country\") vertexText = f.properties.name_long;else if (node.vertex.type === \"customText\") vertexText = node.vertex.customText;else if (node.vertex.type === \"word\") vertexText = node.word; // Initial co-ordinates\n          // TODO: Vertex xOffset, yOffset attributes in country/region data\n\n          let vertexX = node.vertex.x === null ? boundingBox.x : node.vertex.x;\n          let vertexY = node.vertex.y === null ? boundingBox.y : node.vertex.y; // If vertex's default position would exit country/regions' bounds, push it down\n\n          if (!node.vertex.x && !node.vertex.y) {\n            if (vertexX + xOffset * 2 > boundingBox.x + boundingBox.width) {\n              yOffset += prevDiameter;\n              xOffset = 0;\n            } else // Otherwise, increase the offset by the previous vertex's diameter\n              {\n                xOffset += prevDiameter;\n              }\n\n            vertexY += yOffset;\n            vertexX += xOffset;\n          } // Set initial vertex position // TODO: Do it for label, too\n\n\n          if (!node.vertex.x || !node.vertex.y) {\n            node.vertex.x = vertexX;\n            node.vertex.y = vertexY;\n            return editNode(null, journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, node);\n          } // Prepare text element. This is required to calculate circle radius based on text element's width\n\n\n          let vertexG = verticesLabelsG.append(\"g\"); // Group required to have circle and text together\n\n          let preparedText = vertexG.append(\"text\").attr(\"x\", vertexX).attr(\"y\", vertexY).attr(\"fill\", node.vertex.strokeColour).attr(\"text-anchor\", \"middle\") // Centre of circle\n          .attr(\"alignment-baseline\", \"middle\") // Centre of circle\n          .style(\"font-size\", \"16px\").text(vertexText); // Determine initial radius of circle\n          // TODO: Initial scale factor depending on size of country (to stop oversized text from escaping country)\n\n          let innerTextWidth = preparedText.node().getBBox().width;\n\n          if (vertexText.length !== 0 && !node.vertex.radius) // Only scale if font size hasn't been set by user\n            {\n              radius = boundingBox.width / 8;\n              if (radius < innerTextWidth) radius = innerTextWidth / 2 + 5; // Convert text \"diameter\" to radius, add padding\n            }\n\n          preparedText.remove(); // Remove prepared text element. It will not show if appended before the circle\n          // Place edge between this node and next node\n\n          let edges = [];\n\n          if (node.parents) {\n            // Create edge for each parent, originating from this node\n            for (let i = 0; i < node.parents.length; ++i) {\n              // TODO: Arrowheads\n\n              /*\r\n               labelVertexG.append(\"defs\")\r\n               .append(\"marker\")\r\n               .attr(\"id\", \"arrow\")\r\n               .attr(\"markerWidth\", 5).attr(\"markerHeight\", 4)\r\n               .attr(\"refX\", 0).attr(\"refY\", 2)\r\n               .attr(\"orient\", \"auto\")\r\n               .append(\"polygon\")\r\n               .attr(\"points\", \"0 0, 5 2, 0 4\");\r\n               */\n              let parentNode = node.parents[i]; // Determine edge start position\n\n              if (node.vertex.edgeStart === \"top\") startEdgeYOffset = -node.vertex.radius;else if (node.vertex.edgeStart === \"right\") startEdgeXOffset = node.vertex.radius;else if (node.vertex.edgeStart === \"bottom\") startEdgeYOffset = node.vertex.radius;else if (node.vertex.edgeStart === \"left\") startEdgeXOffset = -node.vertex.radius;else {\n                startEdgeXOffset = 0;\n                startEdgeYOffset = 0;\n              } // Determine edge end position\n\n              if (node.vertex.edgeEnd === \"top\") endEdgeYOffset = -node.vertex.radius;else if (node.vertex.edgeEnd === \"right\") endEdgeXOffset = node.vertex.radius;else if (node.vertex.edgeEnd === \"bottom\") endEdgeYOffset = node.vertex.radius;else if (node.vertex.edgeEnd === \"left\") endEdgeXOffset = -node.vertex.radius;else {\n                endEdgeXOffset = 0;\n                endEdgeYOffset = 0;\n              } // Place edge\n\n              edges.push(vertexEdgesG.append(\"line\").attr(\"x1\", node.vertex.x + startEdgeXOffset).attr(\"y1\", node.vertex.y + startEdgeYOffset).attr(\"x2\", parentNode.vertex.x + endEdgeXOffset).attr(\"y2\", parentNode.vertex.y + endEdgeYOffset).attr(\"stroke\", \"black\") // TODO: User choice\n              .attr(\"stroke-width\", \"2px\") // TODO: User choice\n              .attr(\"data-start\", journeyNodeObject.collectionIndex + \"|\" + node.indexChain) // For finding attached edges later\n              .attr(\"data-end\", journeyNodeObject.collectionIndex + \"|\" + parentNode.indexChain)); //.attr(\"marker-end\", \"url(#arrow)\");\n            }\n          }\n\n          let vertex = vertexG.append(\"circle\").attr(\"cx\", vertexX).attr(\"cy\", vertexY).attr(\"r\", radius + \"px\").attr(\"stroke\", node.vertex.strokeColour).attr(\"fill\", node.vertex.fillColour);\n          let text = vertexG.append(\"text\").attr(\"x\", vertexX).attr(\"y\", vertexY).attr(\"fill\", node.vertex.strokeColour).attr(\"text-anchor\", \"middle\") // Centre of circle\n          .attr(\"alignment-baseline\", \"middle\") // Centre of circle\n          .style(\"font-size\", fontSize).text(vertexText);\n          prevDiameter = radius * 2; // Dragging/resizing handlers\n\n          let startXOffset,\n              startYOffset,\n              resizing = false,\n              startX,\n              startY,\n              startSize,\n              newVertexSize,\n              newLabelSize;\n          vertex.on(\"mousemove\", e => {\n            let vertexX = parseFloat(vertex.attr(\"cx\")),\n                vertexY = parseFloat(vertex.attr(\"cy\"));\n            let mouseX = e.layerX,\n                mouseY = e.layerY; // Dimensions of bottom-right corner\n\n            let squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\n            let circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")), 2);\n            let cornerWidth = (squareArea - circleArea) / 4 / 2; // Extract corners, divide by four, width and height are equal length (/2)\n            // Determine corner of circle's box\n\n            const southEastCorner = {\n              xStart: vertexX,\n              xEnd: vertexX + cornerWidth,\n              yStart: vertexY,\n              yEnd: vertexY + cornerWidth\n            }; // Check corner\n\n            if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n              vertex.style(\"cursor\", \"se-resize\");\n            } else vertex.style(\"cursor\", \"grab\");\n          }).call(d3.drag().on(\"start\", e => {\n            let vertexX = parseFloat(vertex.attr(\"cx\")),\n                vertexY = parseFloat(vertex.attr(\"cy\"));\n            let mouseX = e.x,\n                mouseY = e.y;\n            startX = vertexX;\n            startY = vertexY;\n            startXOffset = mouseX - vertexX;\n            startYOffset = mouseY - vertexY; // Dimensions of bottom-right corner\n\n            let squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\n            let circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")), 2);\n            let cornerWidth = (squareArea - circleArea) / 4 / 2; // Extract corners, divide by four, width and height are equal length (/2)\n            // Determine corner of circle's box\n\n            const southEastCorner = {\n              xStart: vertexX,\n              xEnd: vertexX + cornerWidth,\n              yStart: vertexY,\n              yEnd: vertexY + cornerWidth\n            }; // Check corner\n\n            if (mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd && mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd) {\n              resizing = true;\n              startX = mouseX;\n              startY = mouseY;\n              startSize = parseFloat(vertex.attr(\"r\"));\n            }\n          }).on(\"drag\", e => {\n            let mouseX = e.x,\n                mouseY = e.y;\n\n            if (resizing) {\n              if (mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY) {\n                // Resize the vertex\n                let deltaX = mouseX - startX;\n                newVertexSize = startSize + deltaX / 10;\n                if (newVertexSize < 10) newVertexSize = 10; // Floor of 10px to prevent it shrinking into nothingness\n\n                vertex.attr(\"r\", newVertexSize + \"px\"); // Only visually, not updating state itself\n                // Resize the vertex's text\n\n                const paddingOffset = 10;\n                newLabelSize = (newVertexSize * 2 - paddingOffset) / innerTextWidth * 100 + \"%\";\n                text.style(\"font-size\", newLabelSize);\n              }\n            } else {\n              // Move the vertex\n              vertexX = mouseX - startXOffset;\n              vertexY = mouseY - startYOffset;\n              vertex.attr(\"cx\", vertexX).attr(\"cy\", vertexY); // Only visually\n\n              text.attr(\"x\", vertexX).attr(\"y\", vertexY); // Only visually\n              // Move the edges\n\n              let dataEnd = journeyNodeObject.collectionIndex + \"|\" + journeyNodeObject.node.indexChain;\n              let attachedEdges = d3.selectAll(\"line[data-end=\\\"\" + dataEnd + \"\\\"]\"); // Find all edges that end on this node\n\n              if (attachedEdges) {\n                attachedEdges.attr(\"x1\", vertexX + startEdgeXOffset).attr(\"y1\", vertexY + startEdgeYOffset);\n              }\n\n              if (edges) {\n                for (let i = 0; i < edges; ++i) {\n                  edges[i].attr(\"x2\", vertexX + startEdgeXOffset).attr(\"y2\", vertexY + startEdgeYOffset);\n                }\n              }\n            }\n          }).on(\"end\", () => {\n            resizing = false;\n            node.vertex.x = vertexX;\n            node.vertex.y = vertexY;\n            node.vertex.radius = newVertexSize || node.vertex.radius;\n            node.vertex.fontSize = newLabelSize || node.vertex.fontSize;\n            editNode(null, journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, node); //moveVertex(journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, vertexX, vertexY, newVertexSize, newLabelSize); // Set final properties\n          }));\n        }\n      }\n    }); // Graticules (lines on the map)\n\n    const g = svg.append(\"g\");\n    const graticules = g.classed(\"graticules\", true).append(\"path\").attr(\"fill\", \"none\").attr(\"stroke\", \"rgba(0,0,0,.2)\").attr(\"d\", path(d3.geoGraticule()()));\n    /*\r\n    svg.call(d3.zoom().on(\"zoom\", function () {\r\n    \tz = d3.event.transform.k;\r\n    \tdraw(); // TODO: Contain above render code into draw() function\r\n    }));\r\n     */\n    // Clean-up function (kills all SVG elements upon unmounting)\n\n    return function cleanup() {\n      svg.selectAll(\"g\").remove();\n    };\n  });\n\n  function flattenTree(wordArray, node, i, indexChain, collectionIndex) {\n    indexChain += String(i);\n\n    if (node.parents) {\n      for (let j = 0; j < node.parents.length; ++j) {\n        wordArray = flattenTree(wordArray, node.parents[j], j, indexChain + \"->\", collectionIndex);\n      }\n    }\n\n    node.indexChain = indexChain;\n    wordArray.push(node);\n    return wordArray;\n  }\n  /**\r\n   * Finds all nodes in all collections of specified type where the node's language is within the feature's language array\r\n   * @param {*} d The dataset feature (country/region) currently being rendered\r\n   * @param {string} type The type of collection to search for (\"journey\" or \"cognate\")\r\n   */\n\n\n  function findNodes(d, type) {\n    // Search collections\n    if (type === \"cognate\") {\n      for (let c = 0; c < flattenedCollections.length; ++c) {\n        let collection = flattenedCollections[c];\n\n        if (collection.type === \"cognate\") {\n          for (let n = 0; n < collection.words.length; ++n) {\n            let childNode = collection.words[n];\n\n            if (d.properties.languages.includes(childNode.language)) {\n              return {\n                node: childNode,\n                collectionIndex: c,\n                wordIndex: n\n              }; // TODO: Currently only returns first cognate\n            }\n          }\n        }\n      }\n    } else if (type === \"journey\") {\n      let countryNodes = [];\n\n      for (let c = 0; c < flattenedCollections.length; ++c) // Search for all nodes in all collections for this country/region\n      {\n        let collection = flattenedCollections[c];\n\n        if (collection.type === \"journey\") {\n          for (let n = 0; n < collection.words.length; ++n) {\n            let childNode = collection.words[n];\n            if (d.properties.languages.includes(childNode.language)) countryNodes.push({\n              node: childNode,\n              collectionIndex: c\n            });\n          }\n        }\n      }\n\n      return countryNodes;\n    }\n  }\n\n  function findNextNode(collectionIndex, childIndex) {\n    let nextNode;\n    if (flattenedCollections[collectionIndex].words[childIndex + 1]) return {\n      node: flattenedCollections[collectionIndex].words[childIndex + 1],\n      collectionIndex: collectionIndex,\n      wordIndex: childIndex + 1\n    };else return null;\n  }\n  /**\r\n   * Determines country SVG fill colour according to countries' language(s) and the specified colour of that language's cognate node(s)\r\n   * @param d Data attached to DOM element via D3 (i.e. the country)\r\n   * @returns {string} The fill colour, as specified by user in Collection.jsx\r\n   */\n\n\n  function determineFillColour(d) {\n    const nodeObject = findNodes(d, \"cognate\"); // Find node in collections\n\n    if (nodeObject) return nodeObject.node.colour; // Country has associated collection node? Return the colour\n    else return \"white\"; // Otherwise, return white by default for all countries with no associated data\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      /*ref={ref}*/\n      style: {\n        height: \"100%\",\n        width: \"100%\",\n        margin: 0,\n        backgroundColor: \"#3d73ab\"\n        /* The sea */\n\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 608,\n      columnNumber: 4\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 607,\n    columnNumber: 3\n  }, this);\n}\n\n_s(Map, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n_c = Map;\n\nvar _c;\n\n$RefreshReg$(_c, \"Map\");","map":{"version":3,"sources":["D:/xampp/htdocs/COMP3000_LEMA/Project/lema/src/components/Map.jsx"],"names":["React","useEffect","useState","d3","useD3","languageCountries","countries_data","AddEditNodeModal","ContextMenu","Map","props","openContextMenu","bind","addNode","editNode","removeNode","openModal","collections","flattenedCollections","i","length","flattenedTree","flattenTree","words","push","type","console","log","topojson","require","svg","selectAll","countries","features","width","_groups","clientWidth","height","clientHeight","projection","geoConicConformal","center","scale","translate","path","geoPath","countryPaths","append","data","enter","attr","d","determineFillColour","on","e","preventDefault","nodeObject","findNodes","contextMenuItems","text","handler","collectionList","filter","collection","node","properties","languages","collectionIndex","wordIndex","language","clientX","clientY","element","select","vertexEdgesG","classed","verticesLabelsG","each","f","cognateNodeObject","journeyNodeObjects","boundingBox","getBBox","fontSize","label","labelText","name_long","customText","word","x","y","fontColour","style","startXOffset","startYOffset","resizing","startX","startY","startSize","newSize","labelX","parseFloat","labelY","mouseX","layerX","mouseY","layerY","southEastCorner","xStart","xEnd","yStart","yEnd","call","drag","deltaX","indexChain","xOffset","yOffset","prevDiameter","startEdgeXOffset","startEdgeYOffset","endEdgeXOffset","endEdgeYOffset","journeyNodeObject","nextNodeObject","findNextNode","nextNode","radius","vertex","vertexText","vertexX","vertexY","vertexG","preparedText","strokeColour","innerTextWidth","remove","edges","parents","parentNode","edgeStart","edgeEnd","fillColour","newVertexSize","newLabelSize","squareArea","circleArea","Math","PI","pow","cornerWidth","paddingOffset","dataEnd","attachedEdges","g","graticules","geoGraticule","cleanup","wordArray","String","j","c","n","childNode","includes","countryNodes","childIndex","colour","margin","backgroundColor"],"mappings":"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","sourcesContent":["import React, {useEffect, useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {useD3} from \"../hooks/useD3\";\r\nimport languageCountries from \"../supportedLanguages.json\";\r\nimport countries_data from \"../data/countries/countries.json\";\r\nimport {AddEditNodeModal} from \"./AddEditNodeModal\";\r\nimport {ContextMenu} from \"./ContextMenu\";\r\n\r\nexport function Map(props)\r\n{\r\n\t// Prop functions\r\n\tconst openContextMenu = props.openContextMenu.bind(this);\r\n\tconst addNode = props.addNode.bind(this);\r\n\tconst editNode = props.editNode.bind(this);\r\n\tconst removeNode = props.removeNode.bind(this);\r\n\tconst openModal = props.openModal.bind(this);\r\n\r\n\tconst collections = props.collections;\r\n\tlet flattenedCollections = [];\r\n\tfor(let i = 0; i < collections.length; ++i)\r\n\t{\r\n\t\tlet flattenedTree = [];\r\n\t\tflattenedTree = flattenTree(flattenedTree, collections[i].words[0], 0, \"\", i);\r\n\t\tflattenedCollections.push({type: collections[i].type, words: flattenedTree});\r\n\t}\r\n\tconsole.log(\"[== MAP RENDER ==]\");\r\n\r\n\tlet topojson = require(\"topojson\");\r\n\tlet countries_data = require(\"../data/countries/countries.json\");\r\n\r\n\r\n\t// Note: Unfortunately, cannot append React components (then again, that's probably a good thing...)\r\n\tuseEffect(() => {\r\n\t\tlet svg = d3.selectAll(\".map-container\").selectAll(\"svg\");\r\n\t\tlet countries = countries_data.features;\r\n\r\n\t\t// Create path (passed as svg attribute later to draw the countries)\r\n\t\t// TODO: Have it auto-scale as window is dragged\r\n\t\tconst width = svg._groups[0][0].clientWidth;\r\n\t\tconst height = svg._groups[0][0].clientHeight;\r\n\t\tconst projection = d3.geoConicConformal()\r\n\t\t\t.center([8, 52.823]) // Middle of Europe(ish)\r\n\t\t\t.scale(1360)\r\n\t\t\t.translate([width/2, height/2]);\r\n\t\tconst path = d3.geoPath().projection(projection);\r\n\r\n\r\n\r\n\t\t// Draw countries, bind data and handlers\r\n\t\tlet countryPaths = svg.append(\"g\")\r\n\t\t\t.selectAll(\"path\") // svg->g->path\r\n\t\t\t.data(countries)         // svg->g->path\r\n\t\t\t.enter()                 // svg->g->path (create new nodes per data)\r\n\t\t\t.append(\"path\")          // svg->g->path (create new nodes per data)\r\n\t\t\t.attr(\"fill\", (d) => determineFillColour(d))\r\n\t\t\t.on(\"click\", function(e, d){\r\n\t\t\t\t// TODO: Possibly same functions as context menu (see about calling this.onContextMenu() to keep things nice and DRY)\r\n\t\t\t})\r\n\t\t\t.on(\"contextmenu\", function(e, d){\r\n\t\t\t\te.preventDefault(); // Prevent browser context menu from opening\r\n\t\t\t\tconst nodeObject = findNodes(d, \"cognate\");\r\n\r\n\t\t\t\tif(nodeObject)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst contextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add new node (journey)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\t// Add new journey node within the country/region they right-clicked on (there may be multiple nodes in one country/region for journeys)\r\n\t\t\t\t\t\t\t\tlet collectionList = collections.filter(collection => collection.type === \"journey\"); // Journeys only\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={addNode} collectionList={collectionList} node={nodeObject.node} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add sibling node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={addNode} collectionIndex={nodeObject.collectionIndex} node={nodeObject.node} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Edit node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={editNode} collectionIndex={nodeObject.collectionIndex} wordIndex={nodeObject.wordIndex}\r\n\t\t\t\t\t\t\t\t                               node={nodeObject.node} language={nodeObject.node.language} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Remove node (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tremoveNode(e, nodeObject.collectionIndex, nodeObject.wordIndex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: Context menu for adding to new collection, adding to existing collection\r\n\t\t\t\t\tconst contextMenuItems = [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add new node (journey)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tlet collectionList = collections.filter(collection => collection.type === \"journey\"); // Journeys only\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={addNode} collectionList={collectionList} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttext: \"Add to collection (cognate)\", handler: (e) => {\r\n\t\t\t\t\t\t\t\tlet collectionList = collections.filter(collection => collection.type === \"cognate\"); // Cognates only\r\n\t\t\t\t\t\t\t\topenModal(e, <AddEditNodeModal onNodeSubmit={addNode} collectionList={collectionList} language={d.properties.languages} />);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t\topenContextMenu(e, <ContextMenu x={e.clientX} y={e.clientY} items={contextMenuItems} />);\r\n\t\t\t\t}\r\n\r\n\t\t\t})\r\n\t\t\t.on(\"mouseover\", function(e, d){\r\n\t\t\t\tlet element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"white\") // White can't become transparent\r\n\t\t\t\t\telement.attr(\"fill\", \"rgb(230,230,230)\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"0.65\");\r\n\t\t\t})\r\n\t\t\t.on(\"mouseout\", function(e, d){\r\n\t\t\t\tlet element = d3.select(this);\r\n\t\t\t\tif(element.attr(\"fill\") === \"rgb(230,230,230)\") // Reset white\r\n\t\t\t\t\telement.attr(\"fill\", \"white\")\r\n\t\t\t\telse\r\n\t\t\t\t\telement.attr(\"fill-opacity\", \"1\");\r\n\t\t\t})\r\n\t\t\t.attr(\"stroke\", \"black\")\r\n\t\t\t.attr(\"stroke-linejoin\", \"round\")\r\n\t\t\t.attr(\"d\", path);\r\n\r\n\t\t// Cognate labels, journey vertices\r\n\t\tconst vertexEdgesG = svg.append(\"g\").classed(\"vertex-edges\", true); // SVG group for edges\r\n\t\tconst verticesLabelsG = svg.append(\"g\").classed(\"vertices-labels\", true); // SVG group for vertices AND cognate labels\r\n\t\tcountryPaths.each(function(f, i) {\r\n\t\t\t// Only place labels of countries with associated cognate data\r\n\t\t\t// TODO: Make this a setting\r\n\t\t\tlet cognateNodeObject = findNodes(f, \"cognate\");\r\n\t\t\tlet journeyNodeObjects = findNodes(f, \"journey\"); // All nodes across all journey collections belonging to this country/region\r\n\t\t\tif(cognateNodeObject)\r\n\t\t\t{\r\n\t\t\t\t/* Cognate visualisations */\r\n\t\t\t\tlet node = cognateNodeObject.node;\r\n\t\t\t\tlet boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\r\n\t\t\t\tlet fontSize = node.label.fontSize;                 // Font size of the label\r\n\t\t\t\tlet labelText = node.language;                      // Language by default\r\n\t\t\t\tif(node.label.type === \"country\") labelText = f.properties.name_long;\r\n\t\t\t\telse if(node.label.type === \"customText\") labelText = node.label.customText;\r\n\t\t\t\telse if(node.label.type === \"word\") labelText = node.word;\r\n\r\n\t\t\t\t// TODO: Initial scale factor depending on size of country (to stop oversized text from escaping country)\r\n\t\t\t\tif(labelText.length !== 0 && !node.label.fontSize) // Only scale if font size hasn't been set by user\r\n\t\t\t\t{\r\n\t\t\t\t\tif(boundingBox.width < (labelText.length * 16))\r\n\t\t\t\t\t\tfontSize = boundingBox.width/8 + \"px\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Append labels to paths, with co-ordinates according to feature's position on map\r\n\t\t\t\tlet x = (node.label.x === null) ? (boundingBox.x + boundingBox.width/4) : node.label.x;\r\n\t\t\t\tlet y = (node.label.y === null) ? (boundingBox.y + boundingBox.height/2) : node.label.y;\r\n\t\t\t\tlet label = verticesLabelsG.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", x).attr(\"y\", y)\r\n\t\t\t\t\t.attr(\"fill\", node.label.fontColour)\r\n\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t.text(labelText);\r\n\r\n\t\t\t\t// Dragging/resizing handlers\r\n\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startSize, newSize;\r\n\t\t\t\tlabel\r\n\t\t\t\t\t.on(\"mousemove\", (e) => {\r\n\t\t\t\t\t\tlet labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\tlet mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlabel.style(\"cursor\", \"grab\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.call(d3.drag()\r\n\t\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\t\tlet labelX = parseFloat(label.attr(\"x\")), labelY = parseFloat(label.attr(\"y\"));\r\n\t\t\t\t\t\t\tlet mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tstartXOffset = mouseX - labelX;\r\n\t\t\t\t\t\t\tstartYOffset = mouseY - labelY;\r\n\r\n\t\t\t\t\t\t\t// Determine corner of text's box\r\n\t\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\t\txStart: labelX + label.node().getBBox().width - 5,\r\n\t\t\t\t\t\t\t\txEnd: labelX + label.node().getBBox().width + 15,\r\n\t\t\t\t\t\t\t\tyStart: labelY,\r\n\t\t\t\t\t\t\t\tyEnd: labelY + 10\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\t\tstartSize = parseFloat(label.style(\"font-size\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\t\tlet mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Resize the label\r\n\t\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tlet deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\t\tnewSize = startSize + (deltaX / 10);\r\n\t\t\t\t\t\t\t\t\tif(newSize < 5) newSize = 5; // Floor of 5px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\t\tlabel.style(\"font-size\", newSize + \"px\"); // Only visually, not updating state itself\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Move the label\r\n\t\t\t\t\t\t\t\tx = mouseX - startXOffset;\r\n\t\t\t\t\t\t\t\ty = mouseY - startYOffset;\r\n\t\t\t\t\t\t\t\tlabel.attr(\"x\", x).attr(\"y\", y); // Only visually\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\t\tnode.x = x; node.y = y; node.newSize = newSize;\r\n\t\t\t\t\t\t\teditNode(null, cognateNodeObject.collectionIndex, cognateNodeObject.node.indexChain, node);\r\n\t\t\t\t\t\t\t//moveLabel(cognateNodeObject.collectionIndex, cognateNodeObject.node.indexChain, x, y, newSize); // Set final properties\r\n\t\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif(journeyNodeObjects)\r\n\t\t\t{\r\n\t\t\t\t/* Journey visualisations */\r\n\r\n\t\t\t\t// Loop through all journey nodes inside this country/region\r\n\t\t\t\tlet xOffset = 0, yOffset = 0, prevDiameter = 0;\r\n\t\t\t\tlet startEdgeXOffset = 0, startEdgeYOffset = 0, endEdgeXOffset = 0, endEdgeYOffset = 0; // Centre by default\r\n\t\t\t\tfor(let i = 0; i < journeyNodeObjects.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tlet journeyNodeObject = journeyNodeObjects[i];\r\n\t\t\t\t\tlet node = journeyNodeObject.node;\r\n\t\t\t\t\tlet nextNodeObject = findNextNode(journeyNodeObject.collectionIndex, journeyNodeObject.wordIndex);\r\n\t\t\t\t\tlet nextNode = (nextNodeObject) ? nextNodeObject.node : null;\r\n\t\t\t\t\tlet boundingBox = d3.select(this).node().getBBox(); // Get rectangular bounds of country/region\r\n\t\t\t\t\tlet radius = node.vertex.radius || 50;              // Inherit radius (determined later if null)\r\n\t\t\t\t\tlet fontSize = node.vertex.fontSize;\r\n\t\t\t\t\tlet vertexText = node.language;                     // Language by default\r\n\t\t\t\t\tif(node.vertex.type === \"country\") vertexText = f.properties.name_long;\r\n\t\t\t\t\telse if(node.vertex.type === \"customText\") vertexText = node.vertex.customText;\r\n\t\t\t\t\telse if(node.vertex.type === \"word\") vertexText = node.word;\r\n\r\n\t\t\t\t\t// Initial co-ordinates\r\n\t\t\t\t\t// TODO: Vertex xOffset, yOffset attributes in country/region data\r\n\t\t\t\t\tlet vertexX = (node.vertex.x === null) ? (boundingBox.x) : node.vertex.x;\r\n\t\t\t\t\tlet vertexY = (node.vertex.y === null) ? (boundingBox.y) : node.vertex.y;\r\n\r\n\t\t\t\t\t// If vertex's default position would exit country/regions' bounds, push it down\r\n\t\t\t\t\tif(!node.vertex.x && !node.vertex.y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif((vertexX + xOffset*2) > (boundingBox.x + boundingBox.width))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tyOffset += prevDiameter;\r\n\t\t\t\t\t\t\txOffset = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse // Otherwise, increase the offset by the previous vertex's diameter\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\txOffset += prevDiameter;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvertexY += yOffset;\r\n\t\t\t\t\t\tvertexX += xOffset;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Set initial vertex position // TODO: Do it for label, too\r\n\t\t\t\t\tif(!node.vertex.x || !node.vertex.y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY;\r\n\t\t\t\t\t\treturn editNode(null, journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Prepare text element. This is required to calculate circle radius based on text element's width\r\n\t\t\t\t\tlet vertexG = verticesLabelsG.append(\"g\"); // Group required to have circle and text together\r\n\t\t\t\t\tlet preparedText = vertexG.append(\"text\")\r\n\t\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t\t.attr(\"fill\", node.vertex.strokeColour)\r\n\t\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t\t.style(\"font-size\", \"16px\")\r\n\t\t\t\t\t\t.text(vertexText);\r\n\r\n\t\t\t\t\t// Determine initial radius of circle\r\n\t\t\t\t\t// TODO: Initial scale factor depending on size of country (to stop oversized text from escaping country)\r\n\t\t\t\t\tlet innerTextWidth = preparedText.node().getBBox().width;\r\n\t\t\t\t\tif(vertexText.length !== 0 && !node.vertex.radius) // Only scale if font size hasn't been set by user\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tradius = boundingBox.width/8;\r\n\t\t\t\t\t\tif(radius < innerTextWidth) radius = innerTextWidth/2 + 5; // Convert text \"diameter\" to radius, add padding\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpreparedText.remove(); // Remove prepared text element. It will not show if appended before the circle\r\n\r\n\t\t\t\t\t// Place edge between this node and next node\r\n\t\t\t\t\tlet edges = [];\r\n\t\t\t\t\tif(node.parents)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Create edge for each parent, originating from this node\r\n\t\t\t\t\t\tfor(let i = 0; i < node.parents.length; ++i)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// TODO: Arrowheads\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t labelVertexG.append(\"defs\")\r\n\t\t\t\t\t\t\t .append(\"marker\")\r\n\t\t\t\t\t\t\t .attr(\"id\", \"arrow\")\r\n\t\t\t\t\t\t\t .attr(\"markerWidth\", 5).attr(\"markerHeight\", 4)\r\n\t\t\t\t\t\t\t .attr(\"refX\", 0).attr(\"refY\", 2)\r\n\t\t\t\t\t\t\t .attr(\"orient\", \"auto\")\r\n\t\t\t\t\t\t\t .append(\"polygon\")\r\n\t\t\t\t\t\t\t .attr(\"points\", \"0 0, 5 2, 0 4\");\r\n\t\t\t\t\t\t\t */\r\n\r\n\t\t\t\t\t\t\tlet parentNode = node.parents[i];\r\n\r\n\t\t\t\t\t\t\t// Determine edge start position\r\n\t\t\t\t\t\t\tif(node.vertex.edgeStart === \"top\") startEdgeYOffset = -(node.vertex.radius);\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeStart === \"right\") startEdgeXOffset = node.vertex.radius;\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeStart === \"bottom\") startEdgeYOffset = node.vertex.radius;\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeStart === \"left\") startEdgeXOffset = -(node.vertex.radius);\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstartEdgeXOffset = 0; startEdgeYOffset = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Determine edge end position\r\n\t\t\t\t\t\t\tif(node.vertex.edgeEnd === \"top\") endEdgeYOffset = -(node.vertex.radius);\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"right\") endEdgeXOffset = node.vertex.radius;\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"bottom\") endEdgeYOffset = node.vertex.radius;\r\n\t\t\t\t\t\t\telse if(node.vertex.edgeEnd === \"left\") endEdgeXOffset = -(node.vertex.radius);\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tendEdgeXOffset = 0; endEdgeYOffset = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Place edge\r\n\t\t\t\t\t\t\tedges.push(vertexEdgesG.append(\"line\")\r\n\t\t\t\t\t\t\t\t.attr(\"x1\", node.vertex.x + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t.attr(\"y1\", node.vertex.y + startEdgeYOffset)\r\n\t\t\t\t\t\t\t\t.attr(\"x2\", parentNode.vertex.x + endEdgeXOffset)\r\n\t\t\t\t\t\t\t\t.attr(\"y2\", parentNode.vertex.y + endEdgeYOffset)\r\n\t\t\t\t\t\t\t\t.attr(\"stroke\", \"black\")     // TODO: User choice\r\n\t\t\t\t\t\t\t\t.attr(\"stroke-width\", \"2px\") // TODO: User choice\r\n\t\t\t\t\t\t\t\t.attr(\"data-start\", journeyNodeObject.collectionIndex + \"|\" + node.indexChain) // For finding attached edges later\r\n\t\t\t\t\t\t\t\t.attr(\"data-end\", journeyNodeObject.collectionIndex + \"|\" + parentNode.indexChain)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t//.attr(\"marker-end\", \"url(#arrow)\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet vertex = vertexG.append(\"circle\")\r\n\t\t\t\t\t\t.attr(\"cx\", vertexX).attr(\"cy\", vertexY)\r\n\t\t\t\t\t\t.attr(\"r\", radius + \"px\")\r\n\t\t\t\t\t\t.attr(\"stroke\", node.vertex.strokeColour)\r\n\t\t\t\t\t\t.attr(\"fill\", node.vertex.fillColour);\r\n\t\t\t\t\tlet text = vertexG.append(\"text\")\r\n\t\t\t\t\t\t.attr(\"x\", vertexX).attr(\"y\", vertexY)\r\n\t\t\t\t\t\t.attr(\"fill\", node.vertex.strokeColour)\r\n\t\t\t\t\t\t.attr(\"text-anchor\", \"middle\")        // Centre of circle\r\n\t\t\t\t\t\t.attr(\"alignment-baseline\", \"middle\") // Centre of circle\r\n\t\t\t\t\t\t.style(\"font-size\", fontSize)\r\n\t\t\t\t\t\t.text(vertexText);\r\n\t\t\t\t\tprevDiameter = radius*2;\r\n\r\n\t\t\t\t\t// Dragging/resizing handlers\r\n\t\t\t\t\tlet startXOffset, startYOffset, resizing = false, startX, startY, startSize, newVertexSize, newLabelSize;\r\n\t\t\t\t\tvertex.on(\"mousemove\", (e) => {\r\n\t\t\t\t\t\tlet vertexX = parseFloat(vertex.attr(\"cx\")), vertexY = parseFloat(vertex.attr(\"cy\"));\r\n\t\t\t\t\t\tlet mouseX = e.layerX, mouseY = e.layerY;\r\n\r\n\t\t\t\t\t\t// Dimensions of bottom-right corner\r\n\t\t\t\t\t\tlet squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\r\n\t\t\t\t\t\tlet circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")),2);\r\n\t\t\t\t\t\tlet cornerWidth = ((squareArea - circleArea) / 4) / 2; // Extract corners, divide by four, width and height are equal length (/2)\r\n\r\n\t\t\t\t\t\t// Determine corner of circle's box\r\n\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\txStart: vertexX,\r\n\t\t\t\t\t\t\txEnd: vertexX + cornerWidth,\r\n\t\t\t\t\t\t\tyStart: vertexY,\r\n\t\t\t\t\t\t\tyEnd: vertexY + cornerWidth\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvertex.style(\"cursor\", \"se-resize\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvertex.style(\"cursor\", \"grab\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.call(d3.drag()\r\n\t\t\t\t\t\t.on(\"start\", (e) => {\r\n\t\t\t\t\t\t\tlet vertexX = parseFloat(vertex.attr(\"cx\")), vertexY = parseFloat(vertex.attr(\"cy\"));\r\n\t\t\t\t\t\t\tlet mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tstartX = vertexX;\r\n\t\t\t\t\t\t\tstartY = vertexY;\r\n\t\t\t\t\t\t\tstartXOffset = mouseX - vertexX;\r\n\t\t\t\t\t\t\tstartYOffset = mouseY - vertexY;\r\n\r\n\t\t\t\t\t\t\t// Dimensions of bottom-right corner\r\n\t\t\t\t\t\t\tlet squareArea = vertex.node().getBBox().width * vertex.node().getBBox().height;\r\n\t\t\t\t\t\t\tlet circleArea = Math.PI * Math.pow(parseFloat(vertex.attr(\"r\")),2);\r\n\t\t\t\t\t\t\tlet cornerWidth = ((squareArea - circleArea) / 4) / 2; // Extract corners, divide by four, width and height are equal length (/2)\r\n\r\n\t\t\t\t\t\t\t// Determine corner of circle's box\r\n\t\t\t\t\t\t\tconst southEastCorner = {\r\n\t\t\t\t\t\t\t\txStart: vertexX,\r\n\t\t\t\t\t\t\t\txEnd: vertexX + cornerWidth,\r\n\t\t\t\t\t\t\t\tyStart: vertexY,\r\n\t\t\t\t\t\t\t\tyEnd: vertexY + cornerWidth\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Check corner\r\n\t\t\t\t\t\t\tif(mouseX >= southEastCorner.xStart && mouseX <= southEastCorner.xEnd\r\n\t\t\t\t\t\t\t\t&& mouseY >= southEastCorner.yStart && mouseY <= southEastCorner.yEnd)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresizing = true;\r\n\t\t\t\t\t\t\t\tstartX = mouseX;\r\n\t\t\t\t\t\t\t\tstartY = mouseY;\r\n\t\t\t\t\t\t\t\tstartSize = parseFloat(vertex.attr(\"r\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"drag\", (e) => {\r\n\t\t\t\t\t\t\tlet mouseX = e.x, mouseY = e.y;\r\n\t\t\t\t\t\t\tif(resizing)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif(mouseX >= startX && mouseY >= startY || mouseX <= startX && mouseY <= startY)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// Resize the vertex\r\n\t\t\t\t\t\t\t\t\tlet deltaX = mouseX - startX;\r\n\t\t\t\t\t\t\t\t\tnewVertexSize = startSize + (deltaX / 10);\r\n\t\t\t\t\t\t\t\t\tif(newVertexSize < 10) newVertexSize = 10; // Floor of 10px to prevent it shrinking into nothingness\r\n\t\t\t\t\t\t\t\t\tvertex.attr(\"r\", newVertexSize + \"px\"); // Only visually, not updating state itself\r\n\r\n\t\t\t\t\t\t\t\t\t// Resize the vertex's text\r\n\t\t\t\t\t\t\t\t\tconst paddingOffset = 10;\r\n\t\t\t\t\t\t\t\t\tnewLabelSize = ((((newVertexSize*2) - paddingOffset) / innerTextWidth) * 100) + \"%\";\r\n\t\t\t\t\t\t\t\t\ttext.style(\"font-size\", newLabelSize);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Move the vertex\r\n\t\t\t\t\t\t\t\tvertexX = mouseX - startXOffset;\r\n\t\t\t\t\t\t\t\tvertexY = mouseY - startYOffset;\r\n\t\t\t\t\t\t\t\tvertex.attr(\"cx\", vertexX).attr(\"cy\", vertexY); // Only visually\r\n\t\t\t\t\t\t\t\ttext.attr(\"x\", vertexX).attr(\"y\", vertexY); // Only visually\r\n\r\n\t\t\t\t\t\t\t\t// Move the edges\r\n\t\t\t\t\t\t\t\tlet dataEnd = journeyNodeObject.collectionIndex + \"|\" + journeyNodeObject.node.indexChain;\r\n\t\t\t\t\t\t\t\tlet attachedEdges = d3.selectAll(\"line[data-end=\\\"\"+dataEnd+\"\\\"]\"); // Find all edges that end on this node\r\n\t\t\t\t\t\t\t\tif(attachedEdges)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tattachedEdges.attr(\"x1\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t\t.attr(\"y1\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(edges)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfor(let i = 0; i < edges; ++i)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tedges[i].attr(\"x2\", vertexX + startEdgeXOffset)\r\n\t\t\t\t\t\t\t\t\t\t\t\t.attr(\"y2\", vertexY + startEdgeYOffset);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on(\"end\", () => {\r\n\t\t\t\t\t\t\tresizing = false;\r\n\t\t\t\t\t\t\tnode.vertex.x = vertexX; node.vertex.y = vertexY; node.vertex.radius = newVertexSize || node.vertex.radius; node.vertex.fontSize = newLabelSize || node.vertex.fontSize;\r\n\t\t\t\t\t\t\teditNode(null, journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, node);\r\n\t\t\t\t\t\t\t//moveVertex(journeyNodeObject.collectionIndex, journeyNodeObject.node.indexChain, vertexX, vertexY, newVertexSize, newLabelSize); // Set final properties\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Graticules (lines on the map)\r\n\t\tconst g = svg.append(\"g\");\r\n\t\tconst graticules = g.classed(\"graticules\", true)\r\n\t\t\t.append(\"path\")\r\n\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t.attr(\"stroke\", \"rgba(0,0,0,.2)\")\r\n\t\t\t.attr(\"d\", path(d3.geoGraticule()()));\r\n\r\n\t\t/*\r\n\t\tsvg.call(d3.zoom().on(\"zoom\", function () {\r\n\t\t\tz = d3.event.transform.k;\r\n\t\t\tdraw(); // TODO: Contain above render code into draw() function\r\n\t\t}));\r\n\t\t */\r\n\r\n\t\t// Clean-up function (kills all SVG elements upon unmounting)\r\n\t\treturn function cleanup()\r\n\t\t{\r\n\t\t\tsvg.selectAll(\"g\").remove();\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tfunction flattenTree(wordArray, node, i, indexChain, collectionIndex)\r\n\t{\r\n\t\tindexChain += String(i);\r\n\t\tif(node.parents)\r\n\t\t{\r\n\t\t\tfor(let j = 0; j < node.parents.length; ++j)\r\n\t\t\t{\r\n\t\t\t\twordArray = flattenTree(wordArray, node.parents[j], j, indexChain + \"->\", collectionIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnode.indexChain = indexChain;\r\n\t\twordArray.push(node);\r\n\t\treturn wordArray;\r\n\t}\r\n\r\n\t/**\r\n\t * Finds all nodes in all collections of specified type where the node's language is within the feature's language array\r\n\t * @param {*} d The dataset feature (country/region) currently being rendered\r\n\t * @param {string} type The type of collection to search for (\"journey\" or \"cognate\")\r\n\t */\r\n\tfunction findNodes(d, type)\r\n\t{\r\n\t\t// Search collections\r\n\t\tif(type === \"cognate\")\r\n\t\t{\r\n\t\t\tfor(let c = 0; c < flattenedCollections.length; ++c)\r\n\t\t\t{\r\n\t\t\t\tlet collection = flattenedCollections[c];\r\n\t\t\t\tif(collection.type === \"cognate\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet childNode = collection.words[n];\r\n\r\n\t\t\t\t\t\tif(d.properties.languages.includes(childNode.language))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn {node: childNode, collectionIndex: c, wordIndex: n}; // TODO: Currently only returns first cognate\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(type === \"journey\")\r\n\t\t{\r\n\t\t\tlet countryNodes = [];\r\n\t\t\tfor(let c = 0; c < flattenedCollections.length; ++c) // Search for all nodes in all collections for this country/region\r\n\t\t\t{\r\n\t\t\t\tlet collection = flattenedCollections[c];\r\n\t\t\t\tif(collection.type === \"journey\")\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(let n = 0; n < collection.words.length; ++n)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet childNode = collection.words[n];\r\n\r\n\t\t\t\t\t\tif(d.properties.languages.includes(childNode.language))\r\n\t\t\t\t\t\t\tcountryNodes.push({node: childNode, collectionIndex: c});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn countryNodes;\r\n\t\t}\r\n\t}\r\n\tfunction findNextNode(collectionIndex, childIndex)\r\n\t{\r\n\t\tlet nextNode;\r\n\t\tif(flattenedCollections[collectionIndex].words[childIndex+1])\r\n\t\t\treturn {node: flattenedCollections[collectionIndex].words[childIndex+1], collectionIndex: collectionIndex, wordIndex: childIndex+1}\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines country SVG fill colour according to countries' language(s) and the specified colour of that language's cognate node(s)\r\n\t * @param d Data attached to DOM element via D3 (i.e. the country)\r\n\t * @returns {string} The fill colour, as specified by user in Collection.jsx\r\n\t */\r\n\tfunction determineFillColour(d)\r\n\t{\r\n\t\tconst nodeObject = findNodes(d, \"cognate\"); // Find node in collections\r\n\t\tif(nodeObject) return nodeObject.node.colour;   // Country has associated collection node? Return the colour\r\n\t\telse return \"white\";                            // Otherwise, return white by default for all countries with no associated data\r\n\t}\r\n\r\n\r\n\treturn (\r\n\t\t<div className={\"map-container\"}>\r\n\t\t\t<svg\r\n\t\t\t\t/*ref={ref}*/\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\theight: \"100%\",\r\n\t\t\t\t\twidth: \"100%\",\r\n\t\t\t\t\tmargin: 0,\r\n\t\t\t\t\tbackgroundColor: \"#3d73ab\" /* The sea */\r\n\t\t\t\t}}\r\n\t\t\t/>\r\n\t\t</div>\r\n\t);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}